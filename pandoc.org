#+title: Pandoc filters for org documents
#+author: mooss

#+property: header-args :wrap "src text :minipage" :eval no-export :noweb no-export :results output drawer

* Prelude

This document is about altering the structure of generated documents with pandoc filters and by doing that, adding features that will enhance the quality of literate documents.

The later sections are dedicated to the implementation of the filters, except for the last one, where the various lua functions used throughout this document are defined.

** Noweb tools

*** Pandoc output exploration
The following code block will export a =org= code block to a prettified json exposing pandoc's representation.
It's the first tool to reach for when trying to manipulate pandoc's output.

#+name: pandoc-json
#+begin_src bash :var what="" pandoc_args=""
./include.pl pandoc.org ":noweb $what" | pandoc --standalone --from org --to json $pandoc_args | json_pp
#+end_src

This other code block will transform org document to org documents.
It's more useful than it looks at first glance, because it can be used to apply Lua filters to transform pandoc's representation.

#+name: pandoc-org
#+begin_src bash :var what="" pandoc_args=""
./include.pl pandoc.org ":noweb $what" | pandoc --standalone --from org --to org $pandoc_args
#+end_src

Those code blocks can be called from anywhere in this document with org mode's =#+call:= syntax.
For example, a call to =pandoc-org= will look like =#+call: pandoc-org("example", "--filters some-filter.lua")=.

*** Code block inclusion

=include.pl= setup, as explained in =README.org=.
=:noweb= is hardcoded because only noweb inclusions are used here.
#+name: include
#+begin_src bash :var noweb=""
./include.pl pandoc.org ":noweb $noweb"
#+end_src

** Resources

The most important resource I've found is pandoc's Lua filters documentation at https://pandoc.org/lua-filters.
In particular, the section =Lua type reference= (https://pandoc.org/lua-filters#lua-type-reference) details the caracteristics of pandoc's blocks.


* Minipage generation

The goal of this filter is to start from org documents with code blocks having a =:minipage= header argument like the one below (the source code block):

#+name: minipage-noweb-arg
#+begin_src org
,#+name: Minipage example
,#+begin_src text :minipage :exports both
Minipage defined as a noweb argument.
,#+end_src
#+end_src

And to transform them to a block surrounded by embedded latex latex instructions (the target code block):
#+name: minipage-embedded-latex
#+begin_src org
,#+latex: \begin{minipage}{0.95\textwidth}
,#+name: Other minipage example
,#+begin_src text :exports both
Minipage defined as embedded latex instructions.
,#+end_src
,#+latex: \end{minipage}
#+end_src

** Analysis

The starting point to create this filter is to look at the json generated by pandoc for each of the code blocks defined above.

*** Source code block

#+Call: pandoc-json("minipage-noweb-arg") :wrap "src js :minipage"

#+RESULTS:
#+begin_src js :minipage
{
   "blocks" : [
      {
         "c" : [
            [
               "Minipage example",
               [
                  "text"
               ],
               [
                  [
                     "minipage",
                     "yes"
                  ],
                  [
                     "exports",
                     "both"
                  ]
               ]
            ],
            "Minipage defined as a noweb argument.\n"
         ],
         "t" : "CodeBlock"
      }
   ],
   "meta" : {},
   "pandoc-api-version" : [
      1,
      22
   ]
}
#+end_src

I found useful explanations on pandoc's internal json format at this address: https://eul.ink/pandoc/JSON-representation/.

What is happening above is that the =text= block is recognised as an entity of type =CodeBlock=, denoted by the =t= key.
Whereas the content of the code block itself is under the =c= key and is encoded in two parts, metadata and proper content.
In the metadata is enclosed all the information needed (the value of =minipage=).

*** Target code block

#+Call: pandoc-json("minipage-embedded-latex") :wrap "src js :minipage"

#+RESULTS:
#+begin_src js :minipage
{
   "blocks" : [
      {
         "c" : [
            "latex",
            "\\begin{minipage}{0.95\\textwidth}"
         ],
         "t" : "RawBlock"
      },
      {
         "c" : [
            [
               "Other minipage example",
               [
                  "text"
               ],
               [
                  [
                     "exports",
                     "both"
                  ]
               ]
            ],
            "Minipage defined as embedded latex instructions.\n"
         ],
         "t" : "CodeBlock"
      },
      {
         "c" : [
            "latex",
            "\\end{minipage}"
         ],
         "t" : "RawBlock"
      }
   ],
   "meta" : {},
   "pandoc-api-version" : [
      1,
      22
   ]
}
#+end_src

Unsurprisingly, the =\begin{minipage}= and the =\end{minipage}= are found around the =CodeBlock=, inside blocks of type =RawBlock=.
So what is needed to enclose an annotated code block in a minipage is:
 1. Find all =CodeBlock= with a =minipage= in their metadata.
 2. Add a latex =RawBlock= before it to open the minipage.
 3. Add another latex =RawBlock= after it to close the minipage.

** Implementation

For the implementation, I used pandoc's guide on Lua filters (https://pandoc.org/lua-filters.html) and a neat Lua cheatsheet available at https://devhints.io/lua.

A few Lua and pandoc tricks to fully understand the implementation below:
 - The length of a table named =array= is =#array=.
 - Lua tables start at =1=.
 - The simple fact of naming a function =CodeBlock= is enough to tell pandoc that I want it to be applied to code blocks, which is prodigiously simple.
 - Returning =nil= means that the element should not be changed.
 - Returning a table means that I want the elements of this table to be merged in place, where the original element was.

#+name: minipage
#+begin_src lua :eval never
local function has_minipage(block)
   for _, meta in ipairs(block.attributes) do
      if #meta >= 2 and meta[1] == 'minipage' and meta[2] == 'yes' then
         return true
      end
   end
   return false
end

function CodeBlock(block)
   if has_minipage(block) then
      return {
         pandoc.RawBlock('latex', '\\begin{minipage}{0.95\\textwidth}'),
         block,
         pandoc.RawBlock('latex', '\\end{minipage}')
      }
   end
   return nil
end
#+end_src
#+tangle:minipage filters/minipage.lua

** Testing

Exporting an org document to another org document seems to strip off all metadata, but what matters is that the snippet is enclosed within a minipage.

#+Call: pandoc-org("minipage-noweb-arg", "--lua-filter filters/minipage.lua") :wrap "src org :minipage"

#+RESULTS:
#+begin_src org :minipage
\begin{minipage}{0.95\textwidth}
,#+begin_example
  Minipage defined as a noweb argument.
,#+end_example

\end{minipage}
#+end_src

For further testing, generating the pdf for this document (with =make pandoc.pdf=) should suffice.
Currently, the first pretty-printed pandoc json output is too big to fit directly on its initial page, so =minipage= moves it to the next page.


* Noweb calls

I use extensively the =#+call:= syntax (well mostly in this file to be honest) and it doesn't appear in the exported document, leading to a resulting block missing its context.
This filter will insert the call above the results.

Not all =#+call:= directives should be exported.
To make the difference and since org-mode is case insensitive, only capitalised call directives will be exported (meaning =#+Call:=).

** Analysis

The call directive in the first line below should be exported as the line after.
In particular, the name of the code block and its arguments should be exported, but not the subsequent noweb arguments (=:noweb-arg 4 8 15=).
#+name: noweb-call-analysis
#+begin_src org
,#+Call: lost("argument", "16 23 42") :noweb-arg 4 8 15
,*Call to* =lost("argument", "16 23 42"):=
#+end_src

Pandoc ast shows that the block is included as-is inside an org =RawBlock=:
#+Call: pandoc-json("noweb-call-analysis") :wrap "src js :minipage"

#+RESULTS:
#+begin_src js :minipage
{
   "blocks" : [
      {
         "c" : [
            "org",
            "#+Call: lost(\"argument\", \"16 23 42\") :noweb-arg 4 8 15"
         ],
         "t" : "RawBlock"
      },
      {
         "c" : [
            {
               "c" : [
                  {
                     "c" : "Call",
                     "t" : "Str"
                  },
                  {
                     "t" : "Space"
                  },
                  {
                     "c" : "to",
                     "t" : "Str"
                  }
               ],
               "t" : "Strong"
            },
            {
               "t" : "Space"
            },
            {
               "c" : [
                  [
                     "",
                     [
                        "verbatim"
                     ],
                     []
                  ],
                  "lost(\"argument\", \"16 23 42\"):"
               ],
               "t" : "Code"
            }
         ],
         "t" : "Para"
      }
   ],
   "meta" : {},
   "pandoc-api-version" : [
      1,
      22
   ]
}
#+end_src

** Implementation and testing

Most of the work is done by =tokenise= (from the support library).
The bulk of the processing shown here is a slight tweaking of the output.
The call is defined as Python code in order to have syntactic coloration on the strings.
It will probably need some adjustments to avoid conflicting with Python's keywords.

#+name: noweb-call
#+begin_src lua
function RawBlock(block)
   if block.format == 'org' then
      tokens = tokenise(block.text)
      if #tokens > 1 and tokens[1] == '#+Call:'
      then
         call = ''
         for i=2, #tokens do
            current = tokens[i]
            if current ~= ')' then
               call = call .. current
               if current == ',' then
                  call = call .. ' '
               end
            else break
            end
         end
         return {pandoc.Para({
                       pandoc.Strong('Call to'),
                       pandoc.Space(),
                       pandoc.Code(call .. '):', {'', {'python'}})
         })}
      end
   end
   return nil
end
#+end_src
#+depends:noweb-call :noweb tokenise
#+tangle:noweb-call filters/noweb-call.lua

#+Call: pandoc-org("noweb-call-analysis", "--lua-filter filters/noweb-call.lua") :wrap "src org :minipage"

#+RESULTS:
#+begin_src org :minipage
,*Call to* =lost("argument", "16 23 42"):=

,*Call to* =lost("argument", "16 23 42"):=
#+end_src

It's working as expected.

** Limitations

For some reason beyond my knowledge, in certain situation the call directive ends up disappearing.
For example, in the code block below, the call directive is located after a code block and just before =#+RESULTS:=.

#+name: silenced-call-directive
#+begin_src org
,#+begin_src lua
print()
,#+end_src

,#+Call: imoen()
,#+RESULTS:
,#+begin_src org
heya
,#+end_src
#+end_src

#+Call: pandoc-json("silenced-call-directive") :wrap "src js :minipage"

#+RESULTS:
#+begin_src js :minipage
{
   "blocks" : [
      {
         "c" : [
            [
               "",
               [
                  "lua"
               ],
               []
            ],
            "print()\n"
         ],
         "t" : "CodeBlock"
      },
      {
         "c" : [
            [
               "",
               [
                  "org"
               ],
               []
            ],
            "heya\n"
         ],
         "t" : "CodeBlock"
      }
   ],
   "meta" : {},
   "pandoc-api-version" : [
      1,
      22
   ]
}
#+end_src

As can be seen above, the call directive is nowhere to be seen.
To fix this, adding an empty line after the call directive appears to be enough.

#+name: silenced-call-directive-fixed
#+begin_src org
,#+begin_src lua
print()
,#+end_src

,#+Call: imoen()

,#+RESULTS:
,#+begin_src org
heya
,#+end_src
#+end_src

#+Call: pandoc-json("silenced-call-directive-fixed") :wrap "src js :minipage"

#+RESULTS:
#+begin_src js :minipage
{
   "blocks" : [
      {
         "c" : [
            [
               "",
               [
                  "lua"
               ],
               []
            ],
            "print()\n"
         ],
         "t" : "CodeBlock"
      },
      {
         "c" : [
            "org",
            "#+Call: imoen()"
         ],
         "t" : "RawBlock"
      },
      {
         "c" : [
            [
               "",
               [
                  "org"
               ],
               []
            ],
            "heya\n"
         ],
         "t" : "CodeBlock"
      }
   ],
   "meta" : {},
   "pandoc-api-version" : [
      1,
      22
   ]
}
#+end_src


* Lua support library

In this section are gathered some functions made to help me write pandoc filters.
Also included here and there are some notes about how Lua works.

** Data structures

Functions in this section are using the same naming convention:
 - A three letter abbreviation like =tbl= is used to name the data structure.
 - Prefix functions like =prefixtbl= are not modifying the data structure.
 - Suffix functions like =tblsuffix= are modifying the data structure.

*** Tables

Tables are apparently Lua's main data structure and are similar to Python's =dict=.
They are declared with ={}= and are addressable with the usual =[]= operator but also with =.=, as if dealing with attributes:
#+begin_src lua
lost = {four=4, eight=8, twenty_three=23, forty_two=42}
lost.fifteen = 15
lost['sixteen'] = 16
print(lost['fifteen'])
print(lost.sixteen)
#+end_src

#+RESULTS:
#+begin_src text :minipage
15
16
#+end_src

Since print does not print the content of a table, here is a function that does it:
#+name: printtbl
#+begin_src lua :eval never
function printtbl(tbl)
   for key, value in pairs(tbl) do
      print(string.format('%s=`%s`', key, value))
   end
end
#+end_src

Usage:
#+begin_src lua
<<include("printtbl")>>
printtbl({four=4, eight=8, fifteen=15, sixteen=16, twenty_three=23, forty_two=42})
#+end_src

#+RESULTS:
#+begin_src text :minipage
twenty_three=`23`
four=`4`
fifteen=`15`
forty_two=`42`
sixteen=`16`
eight=`8`
#+end_src

As can be seen, the definition order is not kept.

*** Arrays

Arrays in lua are in practice tables with integer indexes.
Which means that they should be iterated on with =ipairs=, not =pairs=.

The following function is useful if one wants to ignore indexes when printing arrays:
#+name: printarr
#+begin_src lua
function printarr(arr)
   for _, value in ipairs(arr) do
      print('`' .. value .. '`')
   end
end
#+end_src

Usage:
#+begin_src lua
<<include("printarr")>>
printarr({4, 8, 15, 16, 23, 42})
#+end_src

#+RESULTS:
#+begin_src text :minipage
`4`
`8`
`15`
`16`
`23`
`42`
#+end_src

To include indexes, when printing, use =printtbl=.
This time, it looks like when using arrays instead of other kind of tables, the order is kept:
#+begin_src lua
<<include("printtbl")>>
printtbl({4, 8, 15, 16, 23, 42})
#+end_src

#+RESULTS:
#+begin_src text :minipage
1=`4`
2=`8`
3=`15`
4=`16`
5=`23`
6=`42`
#+end_src

*** Set

Set are represented as tables with =true= values.
Below are some functions to help manipulate those sets.

#+name: inset
#+begin_src lua
function inset(set, key)
   return set[key] ~= nil
end
#+end_src

#+name: setadd
#+begin_src lua
function setadd(set, key)
   set[key] = true
end
#+end_src

#+name: setdel
#+begin_src lua
function setdel(set, key)
   set[key] = nil
end
#+end_src

** String manipulation

*** Search unescaped characters

The following function returns the position of the first unescaped character in a given substring.
If the unescaped character is not found, the length of the string (aka the position of the last character) is returned.

#+name: next_unescaped
#+begin_src lua :eval never
function next_unescaped(str, byte, position)
   backslash = string.byte('\\')
   was_backslash = str:byte(position) == backslash

   while position < #str do
      if not was_backslash then
         if str:byte(position) == byte then
            return position
         end
         was_backslash = str:byte(position) == backslash
      else
         was_backslash = false
      end
      position = position + 1
   end
   return position
end
#+end_src

Below is a function illustrating its intended usage, extracting quoted substrings.
#+name: find_endquote
#+begin_src lua
function find_endquote(str, position)
   return next_unescaped(str, string.byte('"'), position)
end
#+end_src
#+depends:find_endquote :noweb next_unescaped

Usage:
#+begin_src lua
<<include("find_endquote")>>

function test_find_endquote(str)
   until_endquote = str:sub(1, find_endquote(str, 2))
   print('>', '`' .. until_endquote .. '`')
end

test_find_endquote('There is no endquote.')
test_find_endquote('There is an endquote", this should not appear.')
test_find_endquote('"Mind the \\" backslashes".')
#+end_src

#+RESULTS:
#+begin_src text :minipage
>	`There is no endquote.`
>	`There is an endquote"`
>	`"Mind the \" backslashes"`
#+end_src

*** Ignore bytes

Returns the position of the first character of =str= different from =char=, if any.
Otherwise returns -1.
#+name: skipbyte
#+begin_src lua :eval never
function skipbyte(str, byte, position)
   while position < #str do
      if byte ~= str:byte(position) then
         return position
      end
      position = position + 1
   end
   return -1
end
#+end_src

#+begin_src lua
<<include("skipbyte")>>

function test_skipbyte(str, char)
   skipped = str:sub(skipbyte(str, string.byte(char), 1))
   print('>', '`' .. skipped .. '`')
end

test_skipbyte('       spaces', ' ')
test_skipbyte('xxxxxxxxxxxXs', 'x')
test_skipbyte('Nothing ~ to skip', '~')
#+end_src

#+RESULTS:
#+begin_src text :minipage
>	`spaces`
>	`Xs`
>	`Nothing ~ to skip`
#+end_src

** Tokenisation

This function could stop a clock.
Perhaps I should have better learn how to use Lua's pattern syntax to do this.
I always found tokenisation troublesome anyway.

The goal of this tokenisation function is to keep double quotes as one token.
This function will later be used to process various arguments from noweb.

The problem with =tokenise= is that I did not find how to avoid code duplication between =handle_other= and the main loop.

#+name: tokenise
#+begin_src lua :results output :minipage
function tokenise(input)
   tokens      = {}
   token_start = 1
   separator   = string.byte(' ')
   quote       = string.byte('"')
   position    = skipbyte(input, separator, 1)

   local function make_token(token_end)
      tok = input:sub(token_start, token_end)
      table.insert(tokens, tok)
      token_start = position + 1
   end

   local function handle_separator()
      -- Skip them.
      token_start = skipbyte(input, separator, position)
   end

   local function handle_quote()
      -- Fetch it as one token.
      position = find_endquote(input, position + 1)
      make_token(position)
   end

   local function handle_other()
      while position <= #input do
         current = input:byte(position)
         if current == separator or current == quote then
            -- Exclude last character and bail.
            position = position - 1
            make_token(position)
            return
         end
         position = position + 1
      end
      make_token(-1)
   end

   -- Main loop.
   while position <= #input do
      current = input:byte(position)
      if current == separator then
         handle_separator()
      elseif current == quote then
         handle_quote()
      else
         handle_other()
      end
      position = position + 1
   end

   return tokens
end
#+end_src
#+depends:tokenise :noweb find_endquote skipbyte

Despite its homeliness, it seems to do the job adequately for now.
I still suspect that because of its dubious design it will eventually break.

#+begin_src lua
<<include("tokenise printtbl")>>

function test_tokenise(str)
   print('`' .. str .. '` tokenises to:')
   printtbl(tokenise(str))
   print()
end

test_tokenise('wow such test')
test_tokenise('A more "complex" example   ')
test_tokenise('Things are "becoming \\"tricky\\"", as they say"')
#+end_src

#+RESULTS:
#+begin_src text :minipage
`wow such test` tokenises to:
1=`wow`
2=`such`
3=`test`

`A more "complex" example   ` tokenises to:
1=`A`
2=`more`
3=`"complex"`
4=`example`

`Things are "becoming \"tricky\"", as they say"` tokenises to:
1=`Things`
2=`are`
3=`"becoming \"tricky\""`
4=`,`
5=`as`
6=`they`
7=`say`
8=`"`

#+end_src


