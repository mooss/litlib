#+title: Pandoc filters for org documents
#+property: header-args :wrap "src text :minipage" :eval no-export :noweb no-export

* Prelude

This document is about altering the structure of generated documents with pandoc filters and by doing that, adding features that will enhance the quality of literate documents.

** Tools

The following code block will export a =org= code block to a prettified json exposing pandoc's representation.
It's the first tool to reach for when trying to manipulate pandoc's output.

#+name: pandoc-json
#+begin_src bash :var what=""
./include.pl pandoc.org ":noweb $what" | pandoc --standalone --from org --to json | json_pp
#+end_src

This other code block will transform org document to org documents, with additional arguments transmitted.
It's more useful than it looks at first glance, because it can be used to apply Lua filters to transform pandoc's representation.

#+name: pandoc-org
#+begin_src bash :var what="" pandoc_args=""
./include.pl pandoc.org ":noweb $what" | pandoc --standalone --from org --to org $pandoc_args
#+end_src

Those code blocks can be called from anywhere in this document with org mode's =#+call:= syntax.
For example, a call to =pandoc-org= will look like =#+call: pandoc-org("example", "--filters some-filter.lua")=.

* Minipage generation

The goal of this filter is to start from org documents with code blocks having a =:minipage= header argument like the one below (the source code block):

#+name: minipage-noweb-arg
#+begin_src org
,#+name: Minipage example
,#+begin_src text :minipage :exports both
Minipage defined as a noweb argument.
,#+end_src
#+end_src

And to transform them to a block surrounded by embedded latex latex instructions (the target code block):
#+name: minipage-embedded-latex
#+begin_src org
,#+latex: \begin{minipage}{0.95\textwidth}
,#+name: Other minipage example
,#+begin_src text :exports both
Minipage defined as embedded latex instructions.
,#+end_src
,#+latex: \end{minipage}
#+end_src

** Analysis

The starting point to create this filter is to look at the json generated by pandoc for each of the code blocks defined above.

*** Source code block

#+call: pandoc-json("minipage-noweb-arg")

#+RESULTS:
#+begin_src text :minipage
{
   "blocks" : [
      {
         "c" : [
            [
               "Minipage example",
               [
                  "text"
               ],
               [
                  [
                     "minipage",
                     "yes"
                  ],
                  [
                     "exports",
                     "both"
                  ]
               ]
            ],
            "Minipage defined as a noweb argument.\n"
         ],
         "t" : "CodeBlock"
      }
   ],
   "meta" : {},
   "pandoc-api-version" : [
      1,
      22
   ]
}
#+end_src

I found useful explanations on pandoc's internal json format at this address: https://eul.ink/pandoc/JSON-representation/.

What is happening above is that the =text= block is recognised as an entity of type =CodeBlock=, denoted by the =t= key.
Whereas the content of the code block itself is under the =c= key and is encoded in two parts, metadata and proper content.
In the metadata is enclosed all the information needed (the value of =minipage=).

*** Target code block

#+call: pandoc-json("minipage-embedded-latex")

#+RESULTS:
#+begin_src text :minipage
{
   "blocks" : [
      {
         "c" : [
            "latex",
            "\\begin{minipage}{0.95\\textwidth}"
         ],
         "t" : "RawBlock"
      },
      {
         "c" : [
            [
               "Other minipage example",
               [
                  "text"
               ],
               [
                  [
                     "exports",
                     "both"
                  ]
               ]
            ],
            "Minipage defined as embedded latex instructions.\n"
         ],
         "t" : "CodeBlock"
      },
      {
         "c" : [
            "latex",
            "\\end{minipage}"
         ],
         "t" : "RawBlock"
      }
   ],
   "meta" : {},
   "pandoc-api-version" : [
      1,
      22
   ]
}
#+end_src

Unsurprisingly, the =\begin{minipage}= and the =\end{minipage}= are found around the =CodeBlock=, inside blocks of type =RawBlock=.
So what is needed to enclose an annotated code block in a minipage is:
 1. Find all =CodeBlock= with a =minipage= in their metadata.
 2. Add a latex =RawBlock= before it to open the minipage.
 3. Add another latex =RawBlock= after it to close the minipage.

** Implementation

For the implementation, I used pandoc's guide on Lua filters (https://pandoc.org/lua-filters.html) and a neat Lua cheatsheet available at https://devhints.io/lua.

A few Lua and pandoc tricks to fully understand the implementation below:
 - The length of a table named =array= is =#array=.
 - Lua tables start at =1=.
 - The simple fact of naming a function =CodeBlock= is enough to tell pandoc that I want it to be applied to code blocks, which is prodigiously simple.
 - Returning =nil= means that the element should not be changed.
 - Returning a table means that I want the elements of this table to be merged in place, where the original element was.

#+begin_src lua :tangle filters/minipage.lua :exports code
local function has_minipage(block)
   for _, meta in ipairs(block.attributes) do
      if #meta >= 2 and meta[1] == "minipage" and meta[2] == "yes" then
         return true
      end
   end
   return false
end

function CodeBlock(block)
   if has_minipage(block) then
      return {
         pandoc.RawBlock("latex", "\\begin{minipage}{0.95\\textwidth}"),
         block,
         pandoc.RawBlock("latex", "\\end{minipage}")
      }
   end
   return nil
end
#+end_src

** Testing

Exporting an org document to another org document seems to strip off all metadata, but what matters is that the snippet is enclosed within a minipage.

#+call: pandoc-org("minipage-noweb-arg", "--lua-filter filters/minipage.lua") :wrap "src org :minipage"

#+RESULTS:
#+begin_src org :minipage
\begin{minipage}{0.95\textwidth}
,#+begin_example
  Minipage defined as a noweb argument.
,#+end_example

\end{minipage}
#+end_src

For further testing, generating the pdf for this document (with =make pandoc.pdf=) should suffice.
Currently, the first pretty-printed pandoc json output is too big to fit directly on its initial page, so =minipage= moves it to the next page.
