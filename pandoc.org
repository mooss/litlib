#+title: Pandoc filters for org documents
#+property: header-args :wrap "src text :minipage" :eval no-export :noweb no-export :results output drawer

* Prelude

This document is about altering the structure of generated documents with pandoc filters and by doing that, adding features that will enhance the quality of literate documents.

The later sections are dedicated to the implementation of the filters, except for the last one, where the various lua functions used throughout this document are defined.

** Noweb tools

*** Pandoc output exploration
The following code block will export a =org= code block to a prettified json exposing pandoc's representation.
It's the first tool to reach for when trying to manipulate pandoc's output.

#+name: pandoc-json
#+begin_src bash :var what="" pandoc_args=""
./include.pl pandoc.org ":noweb $what" | pandoc --standalone --from org --to json $pandoc_args | json_pp
#+end_src

This other code block will transform org document to org documents.
It's more useful than it looks at first glance, because it can be used to apply Lua filters to transform pandoc's representation.

#+name: pandoc-org
#+begin_src bash :var what="" pandoc_args=""
./include.pl pandoc.org ":noweb $what" | pandoc --standalone --from org --to org $pandoc_args
#+end_src

Those code blocks can be called from anywhere in this document with org mode's =#+call:= syntax.
For example, a call to =pandoc-org= will look like =#+call: pandoc-org("example", "--filters some-filter.lua")=.

*** Code block inclusion

=include.pl= setup, as explained in =README.org=.
=:noweb= is hardcoded because only noweb inclusions are used here.
#+name: include
#+begin_src bash :var noweb=""
./include.pl pandoc.org ":noweb $noweb"
#+end_src

** Resources

The most important resource I've found is pandoc's Lua filters documentation at https://pandoc.org/lua-filters.
In particular, the section =Lua type reference= (https://pandoc.org/lua-filters#lua-type-reference) details the caracteristics of pandoc's blocks.


* Minipage generation

The goal of this filter is to start from org documents with code blocks having a =:minipage= header argument like the one below (the source code block):

#+name: minipage-noweb-arg
#+begin_src org
,#+name: Minipage example
,#+begin_src text :minipage :exports both
Minipage defined as a noweb argument.
,#+end_src
#+end_src

And to transform them to a block surrounded by embedded latex latex instructions (the target code block):
#+name: minipage-embedded-latex
#+begin_src org
,#+latex: \begin{minipage}{0.95\textwidth}
,#+name: Other minipage example
,#+begin_src text :exports both
Minipage defined as embedded latex instructions.
,#+end_src
,#+latex: \end{minipage}
#+end_src

** Analysis

The starting point to create this filter is to look at the json generated by pandoc for each of the code blocks defined above.

*** Source code block

#+call: pandoc-json("minipage-noweb-arg") :wrap "src js :minipage"

#+RESULTS:
#+begin_src js
{
   "blocks" : [
      {
         "c" : [
            [
               "Minipage example",
               [
                  "text"
               ],
               [
                  [
                     "minipage",
                     "yes"
                  ],
                  [
                     "exports",
                     "both"
                  ]
               ]
            ],
            "Minipage defined as a noweb argument.\n"
         ],
         "t" : "CodeBlock"
      }
   ],
   "meta" : {},
   "pandoc-api-version" : [
      1,
      22
   ]
}
#+end_src

I found useful explanations on pandoc's internal json format at this address: https://eul.ink/pandoc/JSON-representation/.

What is happening above is that the =text= block is recognised as an entity of type =CodeBlock=, denoted by the =t= key.
Whereas the content of the code block itself is under the =c= key and is encoded in two parts, metadata and proper content.
In the metadata is enclosed all the information needed (the value of =minipage=).

*** Target code block

#+call: pandoc-json("minipage-embedded-latex") :wrap "src js :minipage"

#+RESULTS:
#+begin_src js :minipage
{
   "blocks" : [
      {
         "c" : [
            "latex",
            "\\begin{minipage}{0.95\\textwidth}"
         ],
         "t" : "RawBlock"
      },
      {
         "c" : [
            [
               "Other minipage example",
               [
                  "text"
               ],
               [
                  [
                     "exports",
                     "both"
                  ]
               ]
            ],
            "Minipage defined as embedded latex instructions.\n"
         ],
         "t" : "CodeBlock"
      },
      {
         "c" : [
            "latex",
            "\\end{minipage}"
         ],
         "t" : "RawBlock"
      }
   ],
   "meta" : {},
   "pandoc-api-version" : [
      1,
      22
   ]
}
#+end_src

Unsurprisingly, the =\begin{minipage}= and the =\end{minipage}= are found around the =CodeBlock=, inside blocks of type =RawBlock=.
So what is needed to enclose an annotated code block in a minipage is:
 1. Find all =CodeBlock= with a =minipage= in their metadata.
 2. Add a latex =RawBlock= before it to open the minipage.
 3. Add another latex =RawBlock= after it to close the minipage.

** Implementation

For the implementation, I used pandoc's guide on Lua filters (https://pandoc.org/lua-filters.html) and a neat Lua cheatsheet available at https://devhints.io/lua.

A few Lua and pandoc tricks to fully understand the implementation below:
 - The length of a table named =array= is =#array=.
 - Lua tables start at =1=.
 - The simple fact of naming a function =CodeBlock= is enough to tell pandoc that I want it to be applied to code blocks, which is prodigiously simple.
 - Returning =nil= means that the element should not be changed.
 - Returning a table means that I want the elements of this table to be merged in place, where the original element was.

#+begin_src lua :tangle filters/minipage.lua :exports code
local function has_minipage(block)
   for _, meta in ipairs(block.attributes) do
      if #meta >= 2 and meta[1] == 'minipage' and meta[2] == 'yes' then
         return true
      end
   end
   return false
end

function CodeBlock(block)
   if has_minipage(block) then
      return {
         pandoc.RawBlock('latex', '\\begin{minipage}{0.95\\textwidth}'),
         block,
         pandoc.RawBlock('latex', '\\end{minipage}')
      }
   end
   return nil
end
#+end_src

** Testing

Exporting an org document to another org document seems to strip off all metadata, but what matters is that the snippet is enclosed within a minipage.

#+call: pandoc-org("minipage-noweb-arg", "--lua-filter filters/minipage.lua") :wrap "src org :minipage"

#+RESULTS:
#+begin_src org :minipage
\begin{minipage}{0.95\textwidth}
,#+begin_example
  Minipage defined as a noweb argument.
,#+end_example

\end{minipage}
#+end_src

For further testing, generating the pdf for this document (with =make pandoc.pdf=) should suffice.
Currently, the first pretty-printed pandoc json output is too big to fit directly on its initial page, so =minipage= moves it to the next page.

* Lua support library

In this section are gathered some functions made to help me write pandoc filters.
Also included here and there are some notes about how Lua works.

** String manipulation

*** Search unescaped characters

The following function returns the position of the first unescaped character in a given substring.
If the unescaped character is not found, the length of the string (aka the position of the last character) is returned.

#+name: next_unescaped
#+begin_src lua :eval never
function next_unescaped(str, byte, position)
   backslash = string.byte('\\')
   was_backslash = str:byte(position) == backslash

   while position < #str do
      if not was_backslash then
         if str:byte(position) == byte then
            return position
         end
         was_backslash = str:byte(position) == backslash
      else
         was_backslash = false
      end
      position = position + 1
   end
   return position
end
#+end_src

Below is a function illustrating its intended usage, extracting quoted substrings.
#+name: find_endquote
#+begin_src lua
function find_endquote(str, position)
   return next_unescaped(str, string.byte('"'), position)
end
#+end_src
#+depends:find_endquote :noweb next_unescaped

Usage example:
#+begin_src lua
<<include("find_endquote")>>

function test_find_endquote(str)
   until_endquote = str:sub(1, find_endquote(str, 2))
   print('>', '`' .. until_endquote .. '`')
end

test_find_endquote('There is no endquote.')
test_find_endquote('There is an endquote", this should not appear.')
test_find_endquote('"Mind the \\" backslashes".')
#+end_src

#+RESULTS:
#+begin_src text :minipage
>	`There is no endquote.`
>	`There is an endquote"`
>	`"Mind the \" backslashes"`
#+end_src

