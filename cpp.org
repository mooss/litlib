#+property: header-args:cpp :eval never :main no :flags -Wall -std=c++20 :noweb no-export
#+property: header-args :exports both :wrap "src text"
#+options: ^:nil

#+title: LitLib C++
#+subtitle: A collection of C++20 building blocks for literate programming

* Prelude

Mandatory include block to be able to execute examples:
#+name: include
#+begin_src sh :var args="" :results output :wrap "src cpp"
./include.pl "cpp.org" "$args"
#+end_src


* Code generation
:PROPERTIES:
:header-args:
:END:

The class =Pycgen= (Python C++ generator) uses the concept of context managers to help with the task of generating C++ code in python.
#+name: Pycgen
#+begin_src python
class Pycgen:
    def __init__(self, indent_str='    ', level=0):
        self.indent_str = indent_str
        self.level = level
        self.close = []

    def __enter__(self):
        self.level += 1
        if len(self.close) < self.level:
            self.close.append('')

    def __exit__(self, ex_type, ex_value, traceback):
        self.level -= 1
        self.indent(self.close.pop())

    def __call__(self, *lines):
        for line in lines:
            self.indent(line)

    def indent(self, line):
        print(self.indent_str * self.level, end='')
        print(line)

    def par(self, line, open='{', close='}'):
        self(line + ' ' + open)
        self.close.append(close)
        return self

    def struct(self, name):
        return self.par('struct ' + name, close='};')
#+end_src

In a similar vein, =Pyogen= can generate org-mode code blocks, with support for LitLib =#+depends= syntax.
#+name: Pyogen
#+begin_src python
class Pyogen:
    def __init__(self, what, name=None, depends=None):
        if depends is not None: assert name is not None
        what = what.split(' ', maxsplit=1)
        self.first = what[0]
        if len(what) == 2:
            self.rest = ' ' + what[1]
        else:
            self.rest = ''
        self.name = name
        self.depends = depends

    def __enter__(self):
        if self.name is not None:
            print('#+name:', self.name)
        print('#+begin_' + self.first + self.rest)

    def __exit__(self, ex_type, ex_value, traceback):
        print('#+end_' + self.first)
        if self.depends is not None:
            print('#+depends:' + self.name + ' ' + self.depends)
#+end_src

Here is the hello world of =Pyogen= and =Pycgen=:
#+begin_src python :noweb no-export :results output :exports both
<<include(":noweb Pyogen Pycgen")>>
cpp = Pycgen()
with Pyogen('src cpp', name='Pyogen-hw', depends=':cpp iostream'):
    with cpp.par('void hello_world()'):
        cpp('std::cout << "Hello, world!\\n";')
#+end_src

#+RESULTS:
:results:
#+name: Pyogen-hw
#+begin_src cpp
void hello_world() {
    std::cout << "Hello, world!\n";
}
#+end_src
#+depends:Pyogen-hw :cpp iostream
:end:

This generated code can be used elsewhere in the document, like so:
#+begin_src cpp :eval no-export :wrap "src text" :exports both
<<include(":noweb Pyogen-hw")>>
int main() {
    hello_world();
}
#+end_src

#+RESULTS:
#+begin_src text
Hello, world!
#+end_src

This so-called code generation is more of an amusement that a serious endeavour, the situations where it is practical are few and far between, but it can serve.

Note that for the generated code to render well within Emacs, it must be placed in a raw drawer.
The =:wrap= noweb argument should therefore be disabled, which apparently cannot be done at the code block level if it was enabled at the document level.
If that is the case, the only thing to do is to disable it at the section level, by overwriting the property drawer just below the section header like so:
#+begin_src org
,*** Some section
:PROPERTIES:
:header-args:
:END:
#+end_src


* Executable utilities

This section regroups code blocks that can be executed from other org-mode files, using a syntax like this:
#+begin_src cpp :noweb no
<<litlib/cpp.org:code_block_name()>>
#+end_src

Not very useful for now overall, because =include.pl= lacks the functionality to execute code blocks.
# TODO: Add this much-needed functionality. This might prove (very) difficult.

** Special members generation

What is meant by special members are the following elements:
 - Copy constructor.
 - Copy assignment operator.
 - Move constructor.
 - Move assignment operator.
 - Default constructor.
 - Destructor.

#+name: special_members
#+begin_src perl :var args="" :results output
use strict;
use warnings;
use v5.14;
use Text::ParseWords qw/quotewords/;

sub extract_parameters {
    my $parameters_string = shift;
    $parameters_string =~ s/^\s*://
        or die "Parameters string `$parameters_string` does not start with `:`";
    my @parameters = quotewords ':', 1, $parameters_string;
    my %parameters = map {s/\s+$//; my ($h, @t) = quotewords '\s+', 0, $_; $h => \@t}
        @parameters;
    return \%parameters;
}

my %flags = %{extract_parameters $args};

sub take_all {
    my $what = shift;
    return @{ delete($flags{$what}) // []};
}

sub format_array {
    my $array = shift;
    return "[" . join(", ", @$array) . "]";
}

sub take_one {
    my $what = shift;
    my @params = take_all $what;
    die "Precisely one value for :$what is required, got " . format_array(\@params) . "."
        if @params != 1;
    return $params[0];
}

sub present {
    my $what = shift;
    if(defined $flags{$what}) {
        die ":$what is a boolean flag and therefore does not accept any value."
            if @{$flags{$what}} != 0;
        return 1;
    }
    return 0;
}

my $name = take_one('name');
my @default = take_all('default');
my @delete = take_all('delete');

my %shortcuts = (
    'move-only' => [[qw/move move=/], [qw/copy copy= empty/]]
);

my $selected_shortcut;
foreach(keys %shortcuts) {
    if(present $_) {
        die "Cannot use more than one shortcut but :$selected_shortcut and :$_ are present."
            if defined $selected_shortcut;
        $selected_shortcut = $_;
    }
}

if(defined $selected_shortcut) {
    die "Shortcuts are mutually exclusive with :default and :delete."
        if @default != 0 or @delete != 0;
    @default = @{$shortcuts{$selected_shortcut}->[0]};
    @delete  = @{$shortcuts{$selected_shortcut}->[1]};
}

my %signatures = (
    'move'  => "$name($name&&)",
    'move=' => "$name& operator=($name&&)",
    'copy'  => "$name(const $name&)",
    'copy=' => "$name& operator=(const $name&)",
    'empty' => "$name()"
);

die "Nothing to generate, :default and :delete are empty."
    if @default == 0 and @delete == 0;

foreach(@default) {
    die "Invalid default name `$_`."
        if !defined $signatures{$_};
    say $signatures{$_} . '=default;';
}

foreach(@delete) {
    die "Invalid delete name `$_`."
        if !defined $signatures{$_};
    say $signatures{$_} . '=delete;';
}
#+end_src

#+call: special_members(":name vertices :move-only")

#+RESULTS:
#+begin_src text
vertices(vertices&&)=default;
vertices& operator=(vertices&&)=default;
vertices(const vertices&)=delete;
vertices& operator=(const vertices&)=delete;
vertices()=delete;
#+end_src


* Printing

** Type name to string
From https://stackoverflow.com/a/56766138.

#+name: type_str
#+begin_src cpp :noweb-ref litlib
template <typename T>
constexpr auto type_str() noexcept {
    std::string_view name = "Error: unsupported compiler", prefix, suffix;
#ifdef __clang__
    name = __PRETTY_FUNCTION__;
    prefix = "auto type_str() [T = ";
    suffix = "]";
#elif defined(__GNUC__)
    name = __PRETTY_FUNCTION__;
    prefix = "constexpr auto type_str() [with T = ";
    suffix = "]";
#elif defined(_MSC_VER)
    name = __FUNCSIG__;
    prefix = "auto __cdecl type_str<";
    suffix = ">(void) noexcept";
#endif
    name.remove_prefix(prefix.size());
    name.remove_suffix(suffix.size());
    return name;
}
#+end_src
#+depends:type_str :cpp string_view

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb type_str :cpp iostream")>>
using namespace std;
int main(){
    cout << type_str<int>() << "\n";
    const long ft = 42;
    cout << type_str<decltype(ft)>() << "\n";
    cout << type_str<decltype(12.3)>() << "\n";
}
#+end_src

#+RESULTS:
#+begin_src text
int
const long int
double
#+end_src


** Type printer (=print_info=)

#+name: print_info
#+begin_src cpp :noweb-ref litlib
template<typename T>
void print_info() {
    std::cout << type_str<T>() << " -> " << sizeof(T) << " bytes\n";
}
#+end_src
#+depends:print_info :cpp iostream :noweb type_str

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb print_info")>>
using namespace std;

int main(){
    print_info<int>();
    const long ft = 42;
    print_info<decltype(ft)>();
    print_info<decltype(12.3)>();
}
#+end_src

#+RESULTS:
#+begin_src text
int -> 4 bytes
const long int -> 8 bytes
double -> 8 bytes
#+end_src


** Container redirection

This section overload ostream's =<<= operator for some containers.

*** Sequential containers

The code below is an internal helper that prints a given container between square brackets.
This format is a reasonable representation for a sequential container, similar to Python's behaviour.

#+name: sequential_redirection
#+begin_src cpp
namespace container_redirection {
template<class Container>
std::ostream& sequential(std::ostream& os, const Container& container) {
    auto it = container.begin();
    os << "[";
    if(!container.empty()) {
        os << *it;
        for(++it; it != container.end(); ++it)
            os << ", " << *it;
    }
    os << "]";
    return os;
}
}
#+end_src
#+depends:sequential_redirection :cpp ostream

This helper is then used to quickly define =<<= overloads for some common sequential containers.

#+name: <<forward_list
#+begin_src cpp
template<typename T, typename Allocator>
std::ostream& operator<<(std::ostream& os, const std::forward_list<T, Allocator>& container) {
    return container_redirection::sequential(os, container);
}
#+end_src
#+depends:<<forward_list :noweb sequential_redirection :cpp ostream forward_list

#+name: <<span
#+begin_src cpp
template<typename T, std::size_t Extent>
std::ostream& operator<<(std::ostream& os, const std::span<T, Extent>& container) {
    return container_redirection::sequential(os, container);
}
#+end_src
#+depends:<<span :noweb sequential_redirection :cpp ostream span

#+name: <<vector
#+begin_src cpp
template<class T, class Allocator>
std::ostream& operator<<(std::ostream& os, const std::vector<T, Allocator>& container) {
    return container_redirection::sequential(os, container);
}
#+end_src
#+depends:<<vector :noweb sequential_redirection :cpp ostream vector

#+name: <<array
#+begin_src cpp
template<class T, std::size_t N>
std::ostream& operator<<(std::ostream& os, const std::array<T, N>& container) {
    return container_redirection::sequential(os, container);
}
#+end_src
#+depends:<<array :noweb sequential_redirection :cpp ostream array

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb <<forward_list <<span <<vector <<array print-function :cpp forward_list vector array span")>>
int main() {
    print{"1. ||| forward_list |||"};
    std::forward_list<int> lost_list{4, 8, 15, 16, 23, 42};
    print{"lost_list", lost_list};

    print{"\n2. ||| vector |||"};
    std::vector<int> lost_vector{4, 8, 15, 16, 23, 42};
    print{"lost_vector", lost_vector};

    print{"\n3. ||| array |||"};
    std::array<int, 6> lost_array{4, 8, 15, 16, 23, 42};
    print{"lost_array", lost_array};

    print{"\n4. ||| span |||"};
    int lost_carray[] {4, 8, 15, 16, 23, 42};
    print{"lost_carray", lost_carray};
    print{"span(lost_carray)", std::span(lost_carray, 6)};
    print{"span(lost_vector)", std::span(lost_vector)};
    print{"span(lost_array)", std::span(lost_array)};
}
#+end_src

#+RESULTS:
#+begin_src text
1. ||| forward_list |||
lost_list [4, 8, 15, 16, 23, 42]

2. ||| vector |||
lost_vector [4, 8, 15, 16, 23, 42]

3. ||| array |||
lost_array [4, 8, 15, 16, 23, 42]

4. ||| span |||
lost_carray 0x7ffd94877080
span(lost_carray) [4, 8, 15, 16, 23, 42]
span(lost_vector) [4, 8, 15, 16, 23, 42]
span(lost_array) [4, 8, 15, 16, 23, 42]
#+end_src

Trying to directly print a C-style array only prints the address of its first element, as should be expected.
To really print the array, it must be wrapped explicitely in =std::span=.


** Print function

With variadic template and a bit of constructor abuse, it's possible to make a python-style print function accepting any number of arguments, separating them with a space and printing a newline at the end.
What I mean by constructor abuse is that the constructor just below is not really here to construct anything, it is simply the mechanism allowing us to use the =print= struct like a function.
It's only here to trigger the side-effect.

#+name: print-function
#+begin_src cpp :noweb-ref litlib
namespace print_{
struct err {
    constexpr static auto& value = std::cerr;
};

struct out {
    constexpr static auto& value = std::cout;
};

struct format {
    std::string sep = " ";
    std::string end = "\n";
};

}

template<typename Destination=print_::out>
struct print {
  private:
    template<typename T>
    void print_one(const T& el) {
        Destination::value << el;
    }

    template<typename T>
    void print_all(const T& el) { // Last.
        Destination::value << el << format_.end;
    }

    template<typename T, typename... Args>
    void print_all(const T& el, Args... args) {
        print_one(el);
        print_one(format_.sep);
        print_all(args...);
    }

    print_::format format_ = print_::format();

  public:
    // Default formatting.
    template<typename... Args>
    print(Args... args) {
        print_all(args...);
    }

    <<print-function/public>>
};
#+end_src
#+depends:print-function :cpp iostream

Printing to stderr is a bit weird to test because org-mode simply does not display stderr and I do not know how to fix this.

#+begin_src cpp :eval no-export :exports both
<<include(":noweb print-function")>>
using namespace print_;

int main(){
    print<err>{"will", "not", "print"};
    print{"will print", "this", "one", 1, 47.2};
}
#+end_src

#+RESULTS:
#+begin_src text
will print this one 1 47.2
#+end_src

*** Empty line

Adding a default constructor will allow the caller to print empty lines, which is something I like to do from time to time when I want to let the output breathe.

#+begin_src cpp :noweb-ref print-function/public
print() {
    Destination::value << format_.end;
}
#+end_src

*** Customizable formatting

To make the separator and the end delimiter customizable, a bit more magic is needed in the form of a =printer::format= constructor and a parentheses operator.
#+begin_src cpp :noweb-ref print-function/public
print(print_::format fmt): format_(std::move(fmt))
{}

template<typename... Args>
void operator()(Args... args) {
    print_all(args...);
}
#+end_src

Now it's possible to customize the print "function" by first constructing it with a =printer::format= and then using its parentheses operator to print stuff.

#+begin_src cpp :eval no-export :exports both
<<include(":noweb print-function")>>

int main() {
    print{{.sep=" -> ", .end=", this is the end.\n"}}(1, "two", int(7.5 -4), 2. * 2);
}
#+end_src

#+RESULTS:
#+begin_src text
1 -> two -> 3 -> 4, this is the end.
#+end_src

Apparently this src_cpp[]{{.field1=value1, .field2=value2}} syntax is called designated initialization.

Some added bonuses:
 1. It's possible to construct a printer object and to reuse it at will.
 2. The formatting parameters can also be used individually.

#+begin_src cpp :eval no-export :exports both
<<include(":noweb print-function")>>

int main() {
    auto printer = print{{.sep=" < "}};
    printer(4, 8, 15, 16, 23, 42);
    printer("lost", "stargate");
    print{};
    print{{.end=" it's me Imoen"}}("heya");
}
#+end_src

#+RESULTS:
#+begin_src text
4 < 8 < 15 < 16 < 23 < 42
lost < stargate

heya it's me Imoen
#+end_src

Some disadvantages:
 1. The double braced syntax is a bit wonky.
 2. Parameters must be in the correct order, src_cpp[]{print{{.end="\n", .sep=", "}}("test");} will not compile.
 3. It's possible to make an incorrect call by mistake without it triggering a compilation error.
    #+begin_src cpp :eval no-export :exports both
<<include(":noweb print-function")>>
int main() {
    print{.sep=", ", .end="\n"}("test");
}
    #+end_src

    #+RESULTS:
    #+begin_src text
    ,  

    test
    #+end_src
    I don't know why this is allowed but it evidently is.

 4. The syntax is inconsistent because for some reason I don't understand, src_cpp[]{std::string a("3"); print(a);} does not compile, whereas src_cpp[]{std::string a("3"); print{a});} does.

    So my guideline would be to use braces when using the default formatting and parens when using custom formatting.


** Log function calls

The goal here is to make a tool that will make it easy to log the function calls being done, for debugging purposes.
Since this tool was a bit complex to put in place, some implementation details have been hidden inside the namespace =details=:
#+begin_src cpp :noweb-ref log_call
namespace details {
<<details/log_call>>
}
#+end_src
#+depends:log_call :cpp string iostream

*** Arguments logging

Most arguments are logged as-is, except for strings which are enclosed in quote, to make things more readable.
#+begin_src cpp :noweb-ref details/log_call
template<typename T>
void log_one_argument(const T& arg) {
    std::cout << arg;
}

void log_one_argument(const char* arg) {
    std::cout << '"' << arg << '"';
}

void log_one_argument(const std::string& arg) {
    log_one_argument(arg.c_str());
}
#+end_src

The heavy lifting of arguments logging is done by the three function below, who respectively handle the case where no arguments are left, the case where one argument is left and the case where more than one argument is left.
In essence, a call to =log_call_arguments= is resolved with recursive calls to the last function, which progressively consumes the =tail= and the other function are special cases to tidy up the output.
#+begin_src cpp :noweb-ref details/log_call
void log_call_arguments() {
    std::cout << ");\n";
}

template<typename T>
void log_call_arguments(const T& last) {
    log_one_argument(last);
    log_call_arguments();
}

template<typename T, typename... Args>
void log_call_arguments(const T& head, Args... tail) {
    log_one_argument(head);
    std::cout << ", ";
    log_call_arguments(tail...);
}
#+end_src

*** =log_call=

Most of what is needed to log simple function calls is handled by =log_call_arguments=, only the function name and the opening paren is missing:
#+begin_src cpp :noweb-ref log_call
template<typename... Args>
void log_call(const char* function_name, Args... args) {
    std::cout << "-> " << function_name << '(';
    details::log_call_arguments(args...);
}
#+end_src

In practice, using this function looks like this:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb log_call")>>

int main() {
    auto sixteen = 16;
    auto twenty_three = 23;
    const char* forty_two = "forty two";
    log_call("log_call", 4, 8, 15, sixteen, twenty_three, forty_two, std::string("string"));
}
#+end_src

#+RESULTS:
#+begin_src text
-> log_call(4, 8, 15, 16, 23, "forty two", "string");
#+end_src

*** Macro

This very handy macro can be used to both log and then call a function:
#+begin_src cpp :noweb-ref log_call
#define LOG_AND_CALL(function, ...) log_call(#function, __VA_ARGS__); function(__VA_ARGS__);
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb log_call")>>

void hello(const std::string& message) {
    std::cout << "hello, " << message << "\n";
}

int main() {
    LOG_AND_CALL(hello, "universe!")
}
#+end_src

#+RESULTS:
#+begin_src text
-> hello("universe!");
hello, universe!
#+end_src


* Various utilities

This section is dedicated to utilities without overarching themes.

** Sum of a container

I didn't like the idea of using =std::accumulate= with a begin iterator, a end iterator and a mandatory neutral element, so I made the =sum= template for a more Python-like experience.

I also didn't like the fact that using =std::accumulate= specifically for this it adds a dependency.
Limiting dependencies is crucial to LitLib's developpement style since everything needs to be recompiled everytime.

#+name: sum
#+begin_src cpp
template<class Container>
typename Container::value_type sum(const Container& source, typename Container::value_type neutral=0) {
    for(const auto& el: source)
        neutral += el;
    return neutral;
}
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb sum print-function :cpp vector array span")>>

int main() {
    std::vector<int> lost_v{4, 8, 15, 16, 23, 42};
    std::array<int, 6> lost_a{4, 8, 15, 16, 23, 42};
    std::span<int> lost_s(lost_v);
    print{"Sum of lost numbers with a std::vector:", sum(lost_v)};
    print{"Same thing with a std::array:", sum(lost_a)};
    print{"Same thing with a std::span:", sum(lost_s)};
}
#+end_src

#+RESULTS:
#+begin_src text
Sum of lost numbers with a std::vector: 108
Same thing with a std::array: 108
Same thing with a std::span: 108
#+end_src
\\

This template does not work directly with C arrays but wrapping them in =std::span= makes it work:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb sum print-function :cpp span")>>
int main() {
    float lost[]{4, 8, 15, 16, 23, 42};
    print{"Sum of lost numbers with a C array, via std::span:", sum(std::span(lost))};
}
#+end_src

#+RESULTS:
#+begin_src text
Sum of lost numbers with a C array, via std::span: 108
#+end_src


** Finaliser

=finaliser= is a class that can be returned from a function and trigger a side effect when the object is destroyed, thus tying the action to the scope of the =finaliser=.
It is an alternative version of the unimplemented =anchor= class discussed in a later section.
#+name: finaliser
#+begin_src cpp
template<typename Callable, typename State=int>
class finaliser {
  public:
    finaliser(Callable side_effect):
        side_effect_(std::move(side_effect))
    {}

    finaliser(State initial_state, Callable side_effect):
        side_effect_(std::move(side_effect)),
        state_(std::move(initial_state))
    {}

    ~finaliser() {
        side_effect_(state_);
    }

    finaliser(const finaliser&)=delete;
    finaliser& operator=(const finaliser&)=delete;
    finaliser(finaliser&&)=delete;
    finaliser& operator=(finaliser&&)=delete;
    finaliser()=delete;

  protected:
    State state_;
    Callable side_effect_;
};
#+end_src

Some notes on this implementation:
 - A state is baked in to allow some customisation of the side effect's behaviour by extending =finaliser=.
 - I'm constructing with =std::move= because I assume that it doesn't hurt in the cases where it's useless (with =int= in particular) and that it can be useful should someone need to store a huge state in here.
 - Every special member function under the sun is deleted because, by default, a given side effect should only be called once.

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb finaliser print-function <<vector :cpp vector")>>

[[nodiscard("Will cleanup immediately.")]]
auto cleanup_later(std::vector<int>& numbers) {
    return finaliser([&](int){
        print{"Will clean", numbers};
        numbers.clear();
        print{"Die alone", numbers};
    });
}

int main() {
    print{"Live together."};
    std::vector<int> a_scenario_with_loose_ends{4, 8, 15, 16, 23};
    auto finale = cleanup_later(a_scenario_with_loose_ends);
    print{"Adding 42."};
    a_scenario_with_loose_ends.push_back(42);
}
#+end_src

#+RESULTS:
#+begin_src text
Live together.
Adding 42.
Will clean [4, 8, 15, 16, 23, 42]
Die alone []
#+end_src

Note that when the return value is ignored, the side effect is enacted immediately, resulting in the following output:
#+begin_src text
Live together.
Will clean [4, 8, 15, 16, 23]
Die alone []
Adding 42.
#+end_src

This can be problematic but I have no solution, only the slight mitigation of using the =nodiscard= attribute to generate a compiler warning should a return value be ignored.

For an example using the internal state, see =subscription= in the next section.


** Subscription

A =subscription= object provides a =cancel= method that will notify the side effect of this state change.
Cancelling the subscription will also change the internal state to =already_cancelled=, to allow the side effect to make the difference between the destruction of an active subscription and that of a cancelled subscription.
As should be expected, a subscription can only be cancelled once, additional cancelling will not trigger the side effect again.

#+name: subscription
#+begin_src cpp :minipage
enum class subscription_state {active, cancel, already_cancelled};

template<typename Callable>
struct subscription: public finaliser<Callable, subscription_state> {
    using state = subscription_state;
    subscription(Callable side_effect):
        finaliser<Callable, subscription_state>(state::active, std::move(side_effect))
    {}

    void cancel() {
        if(this->state_ == state::active) {
            this->side_effect_(state::cancel);
            this->state_ = state::already_cancelled;
        }
    }
};
#+end_src
#+depends:subscription :noweb finaliser

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb subscription print-function")>>

auto verbose_subscription() {
    return subscription([](auto state){
        using s = subscription_state;
        if(state == s::active)
            print{"active"};
        else if(state == s::cancel)
            print{"cancel"};
        else if(state == s::already_cancelled)
            print{"already cancelled"};
    });
}

int main() {
    auto will_not_cancel = verbose_subscription();
    auto will_cancel = verbose_subscription();
    will_cancel.cancel();
    will_cancel.cancel();
    print{"End of scope."};
}
#+end_src

#+RESULTS:
#+begin_src text
cancel
End of scope.
already cancelled
active
#+end_src

As desired, the second cancellation does nothing.


* Cool tricks (don't try this at home)

This section is dedicated to weird C++ voltige.
It might be dangerous, useless or plain stupid but it is (subjectively) always interesting and can raise new way to abuse the language.

** Mandatory keyword arguments

Designated initialisers in C++20 enable a syntax reminiscent to Python keyword arguments, although more verbose and limited.
A problem is that there is, to my knowledge, no built-in way to specify that a keyword argument is mandatory.

Let's use the example of the following =user= class:
#+name: example-mandatory-user
#+begin_src cpp
class user {
  public:
    struct keyword_arguments {
        std::string group = "others";
        std::string name;
        unsigned long id;
    };
    user(keyword_arguments&& kwargs):
        group_(std::move(kwargs.group)),
        name_(std::move(kwargs.name)),
        id_(kwargs.id)
    {
        print{"group:", group_};
        print{"name:", name_};
        print{"id:", id_};
    }

  private:
    std::string group_, name_;
    unsigned long id_;
};
#+end_src
#+depends:example-mandatory-user :noweb print-function :cpp string

In the following executable, since nothing has been defined for =name= and =id=, the default value for =string= and =unsigned int= are used instead.
This code is perfectly valid, it compiles and executes without problem.
#+begin_src cpp :eval no-export :flags -Wall -std=c++20 :noweb no-export :exports both :minipage
<<include(":noweb example-mandatory-user")>>

int main() {
    user richard({});
}
#+end_src

#+RESULTS:
#+begin_src text
group: others
name: 
id: 0
#+end_src

To force an error when =name= and =id= are not defined, the =mandatory= template can be used.
#+name: mandatory
#+begin_src cpp :minipage
template<typename T>
class mandatory {
  public:
    template<typename... Args>
    mandatory(Args&&... args): value_(std::forward<Args>(args)...)
    {}
    mandatory()=delete;

    const T& operator*() const {return value_;}
    T& operator*() {return value_;}

  private:
    T value_;
};
#+end_src

Some remarks about =mandatory=:
 - The trick is that since the default constructor is deleted, fields wrapped in =mandatory= cannot be silently given a default value.
 - The variadic-template-forwarding constructor gives some flexibility to the way arguments can be assigned.
   In particular without it =std::string= assignments like ={.name = "ricardo"}= fail silently because, I assume, C++ then considers =.name= to be a =char *=.
 - The =*= operator must be used to extract the value since I did not managed to make a working =T= conversion operator.
   I assume move operations performed on the references returned by this operator will work as expected but I'm way out of my knowledge zone.
\\

Beyond declaring =name= and =id= as mandatory fields, this is not fully transparent as some adaptation to the =user= class is required, in the form of putting an asterisk in front of the mandatory arguments when they are used:
#+name: example-mandatory-user-fixed
#+begin_src cpp
class user {
  public:
    struct keyword_arguments {
        std::string group = "others";
        mandatory<std::string> name;
        mandatory<unsigned long> id;
    };
    user(keyword_arguments&& kwargs):
        group_(std::move(kwargs.group)),
        name_(std::move(*kwargs.name)),
        id_(*kwargs.id)
    {
        print{"group:", group_};
        print{"name:", name_};
        print{"id:", id_};
    }

  private:
    std::string group_, name_;
    unsigned long id_;
};
#+end_src
#+depends:example-mandatory-user-fixed :noweb mandatory print-function :cpp string

Now the following code does not compile:
#+begin_src cpp :eval no-export :flags -Wall -std=c++20 :noweb no-export :minipage
<<include(":noweb example-mandatory-user-fixed")>>

int main() {
    user richard({});
}
#+end_src

I am instead greeted by the following error messages:
#+begin_src default
/tmp/babel-QfQ93l/C-src-wPBlHJ.cpp: In function ‘int main()’:
/tmp/babel-QfQ93l/C-src-wPBlHJ.cpp:104:20: error: use of deleted function ‘mandatory<T>::mandatory() [with T = std::__cxx11::basic_string<char>]’
  104 |     user richard({});
      |                    ^
/tmp/babel-QfQ93l/C-src-wPBlHJ.cpp:16:5: note: declared here
   16 |     mandatory()=delete;
      |     ^~~~~~~~~
/tmp/babel-QfQ93l/C-src-wPBlHJ.cpp:104:20: error: use of deleted function ‘mandatory<T>::mandatory() [with T = long unsigned int]’
  104 |     user richard({});
      |                    ^
/tmp/babel-QfQ93l/C-src-wPBlHJ.cpp:16:5: note: declared here
   16 |     mandatory()=delete;
      |     ^~~~~~~~~
#+end_src
Which are surprisingly appropriate, I am pleasantly surprised.

If only one mandatory argument is supplied, a compilation error is also triggered for the missing field.
On the other hand, the following code works as expected:
#+begin_src cpp :eval no-export :flags -Wall -std=c++20 :noweb no-export :exports both :minipage
<<include(":noweb example-mandatory-user-fixed")>>

int main() {
    user richard({.name = "ricardo", .id = 4815162342});
}
#+end_src

#+RESULTS:
#+begin_src text
group: others
name: ricardo
id: 4815162342
#+end_src


** Anchor (fun with(out) RVO)

The initial goal of the =anchor= is to have a function returning an =anchor= object that will perform an action on destruction but that action depends on whether the object was ignored.
Metaphorically, the function is a boat throwing an anchor that is either lost (the return value is ignored) or touches the seafloor (the return value is assigned).
But really the anchor terminology was chosen because it's about anchoring something in another scope.

The paragraph above talked about an initial goal because I didn't manage to make it work.
To be precise, I didn't manage to know whether the =anchor= was ignored or not.
Therefore =anchor= is not implemented but it is still explored in the rest of this section.

*** Bypassing RVO

A problem with =anchor= is that in order to known whether it has been assigned, it must rely on side effect enacted by copy constructors.
A naive implementation will not work because return value optimisation (RVO) will bypass the copy operation.
Thus a mechanism must be put in place to bypass RVO itself.

From what I understand, C++ compilers are not authorised to optimise away named volatile objects (in other words to perform NRVO on them).
I hope that's true, it at least seems to be what is meant by the following passage from [[https://en.cppreference.com/w/cpp/language/copy_elision#Non-mandatory_elision_of_copy.2Fmove_.28since_C.2B.2B11.29_operations][cppreference.com]][fn::Consulted on 2021-08-08.], about when compilers are *permitted* to perform copy elision:
#+begin_quote
In a return statement, when the operand is the name of a non-volatile object with automatic storage duration, which isn't a function parameter or a catch clause parameter, and which is of the same class type (ignoring cv-qualification) as the function return type. This variant of copy elision is known as NRVO, "named return value optimization".
#+end_quote
What's important here is that this passage states that a non-volatile named object can be elided, which to me implies that volatile named objects just cannot be elided in a return statement.

*** Remove volatile qualifier

To implement =anchor=, a way to remove a volatile qualifier will be needed because nothing works otherwise.
Forcibly ignoring a qualifier is a bit brutal but I have no problem with the idea here since =volatile= is only used to bypass RVO.
It turns out that const casts also removes volatile qualifiers:
#+name: unvolatile
#+begin_src cpp
template<typename T>
constexpr T& unvolatile(volatile T& arg) {
    return *const_cast<T*>(&arg);
}
#+end_src

Usage:
#+begin_src cpp :eval no-export :flags -Wall -std=c++17 :noweb no-export :exports both
<<include(":noweb unvolatile print-function :cpp string")>>
int main() {
    std::string lo("4 8 15");
    volatile std::string st("16 23 42");
    print{lo, unvolatile(st)};
}
#+end_src

#+RESULTS:
#+begin_src text
4 8 15 16 23 42
#+end_src

Note that without =unvolatile=, the previous code block fails with the following error:
#+begin_src default
error: no matching function for call to ‘std::__cxx11::basic_string<char>::basic_string(volatile string&)’
#+end_src

*** Observing RVO

This section will show how RVO can be bypassed with =volatile= but also why trying to check if a return value was ignored cannot be done this way.
To fulfill this, the =talkative= struct updates its state everytime a relevant event occurs and also prints said event.

#+name: talkative-example
#+begin_src cpp
struct talkative {
    talkative(const std::string& initial_state):
        state(initial_state)
    {}

    talkative(const talkative& other):
        state(other.state)
    {process("copy_c");}

    talkative(volatile talkative&& other):
        state(std::move(unvolatile(other.state)))
    {
        process("volatile-move_c");
        unvolatile(other.state) = "Stolen volatile!";
    }

    talkative(talkative&& other):
        state(std::move(other.state))
    {
        process("move_c");
        unvolatile(other.state) = "Stolen!";
    }

    ~talkative() {
        print{"destroying:", state};
        // Just for sanity's sake.
        state += ", destroyed";
    }

    talkative& operator=(const talkative&)=delete;
    talkative& operator=(talkative&&)=delete;
    talkative()=delete;

    std::string state;
    void process(std::string const& event) {
        print{event};
        state += ", " + event;
    }
};
#+end_src
#+depends:talkative-example :noweb print-function unvolatile :cpp string

=talkative= is used below to generate a trace explaining what happens.
#+begin_src cpp :eval no-export :flags -Wall -std=c++20 :noweb no-export :exports both
<<include(":noweb talkative-example print-function type_str :cpp string")>>

int n = 1;
void title(std::string const& name) {
    print{std::string("\n") + std::to_string(n) + ".", "|||", name, "|||"};
    ++n;
}

talkative return_plain(std::string const& initial) {
    title(initial);
    talkative result(initial);
    return result;
}

talkative return_move(std::string const& initial) {
    title(initial);
    talkative result(initial);
    return std::move(result);
}

talkative return_volatile(std::string const& initial) {
    title(initial);
    volatile talkative result(initial);
    return result;
}

int main() {
    auto result_plain = return_plain("Plain captured");
    auto result_move = return_move("Move captured");
    auto result_volatile = return_volatile("Volatile captured");

    return_plain("Plain ignored");
    return_move("Move ignored");
    return_volatile("Volatile ignored");

    title("Types");
    print{"Type of result_plain:", type_str<decltype(result_plain)>()};
    print{"Type of result_move:", type_str<decltype(result_move)>()};
    print{"Type of result_volatile:", type_str<decltype(result_volatile)>()};
    volatile talkative explicitely_volatile("ignoreme");
    print{"Type of explicitely_volatile:", type_str<decltype(explicitely_volatile)>()};

    title("End of scope");
}
#+end_src

#+RESULTS:
#+begin_src text

1. ||| Plain captured |||

2. ||| Move captured |||
move_c
destroying: Stolen!

3. ||| Volatile captured |||
volatile-move_c
destroying: Stolen volatile!

4. ||| Plain ignored |||
destroying: Plain ignored

5. ||| Move ignored |||
move_c
destroying: Stolen!
destroying: Move ignored, move_c

6. ||| Volatile ignored |||
volatile-move_c
destroying: Stolen volatile!
destroying: Volatile ignored, volatile-move_c

7. ||| Types |||
Type of result_plain: talkative
Type of result_move: talkative
Type of result_volatile: talkative
Type of explicitely_volatile: volatile talkative

8. ||| End of scope |||
destroying: ignoreme
destroying: Volatile captured, volatile-move_c
destroying: Move captured, move_c
destroying: Plain captured
#+end_src

To summarise the output above:
 1. Nothing happens, =result_plain= is constructed in place because of RVO.
 2. The result is moved into =result_move= via the move constructor and the original is destroyed.
 3. The result is moved into =result_volatile= via the volatile move constructor and the original is destroyed.
 4. The plain result is destroyed.
 5. The result is moved into a temporary and both are destroyed.
 6. The result is moved into a temporary and both are destroyed.
 7. All captured results are plain =talkative=.
 8. The destructors are called at the end of scope.

This is not what I hoped because there is no way to know whether the variable was ignored.
What I hoped was that returning a named volatile would not construct a plain object, unless the return was assigned to something.

Some lessons learned:
 - RVO can indeed be bypassed by returning a named volatile.
 - It can apparently be bypassed in a similar way with =std::move= but with a compiler warning telling you not to do that.
