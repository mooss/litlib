#+property: header-args:cpp :eval never :main no :flags -Wall -std=c++20 :noweb no-export
#+property: header-args :exports both :wrap "src text"
#+options: ^:nil

#+title: LitLib C++
#+subtitle: A collection of C++20 building blocks for literate programming

* Prelude

Mandatory include block to be able to execute examples:
#+name: include
#+begin_src sh :var args="" :results output :wrap "src cpp"
./include.pl "cpp.org" "$args"
#+end_src


* Code generation
:PROPERTIES:
:header-args:
:END:

The class =Pycgen= (Python C++ generator) uses the concept of context managers to help with the task of generating C++ code in python.
#+name: Pycgen
#+begin_src python
class Pycgen:
    def __init__(self, indent_str='    ', level=0):
        self.indent_str = indent_str
        self.level = level
        self.close = []

    def __enter__(self):
        self.level += 1
        if len(self.close) < self.level:
            self.close.append('')

    def __exit__(self, ex_type, ex_value, traceback):
        self.level -= 1
        self.indent(self.close.pop())

    def __call__(self, *lines):
        for line in lines:
            self.indent(line)

    def indent(self, line):
        print(self.indent_str * self.level, end='')
        print(line)

    def par(self, line, open='{', close='}'):
        self(line + ' ' + open)
        self.close.append(close)
        return self

    def struct(self, name):
        return self.par('struct ' + name, close='};')
#+end_src

In a similar vein, =Pyogen= can generate org-mode code blocks, with support for LitLib =#+depends= syntax.
#+name: Pyogen
#+begin_src python
class Pyogen:
    def __init__(self, what, name=None, depends=None):
        if depends is not None: assert name is not None
        what = what.split(' ', maxsplit=1)
        self.first = what[0]
        if len(what) == 2:
            self.rest = ' ' + what[1]
        else:
            self.rest = ''
        self.name = name
        self.depends = depends

    def __enter__(self):
        if self.name is not None:
            print('#+name:', self.name)
        print('#+begin_' + self.first + self.rest)

    def __exit__(self, ex_type, ex_value, traceback):
        print('#+end_' + self.first)
        if self.depends is not None:
            print('#+depends:' + self.name + ' ' + self.depends)
#+end_src

Here is the hello world of =Pyogen= and =Pycgen=:
#+begin_src python :noweb no-export :results output :exports both
<<include(":noweb Pyogen Pycgen")>>
cpp = Pycgen()
with Pyogen('src cpp', name='Pyogen-hw', depends=':cpp iostream'):
    with cpp.par('void hello_world()'):
        cpp('std::cout << "Hello, world!\\n";')
#+end_src

#+RESULTS:
:results:
#+name: Pyogen-hw
#+begin_src cpp
void hello_world() {
    std::cout << "Hello, world!\n";
}
#+end_src
#+depends:Pyogen-hw :cpp iostream
:end:

This generated code can be used elsewhere in the document, like so:
#+begin_src cpp :eval no-export :wrap "src text" :exports both
<<include(":noweb Pyogen-hw")>>
int main() {
    hello_world();
}
#+end_src

#+RESULTS:
#+begin_src text
Hello, world!
#+end_src

This so-called code generation is more of an amusement that a serious endeavour, the situations where it is practical are few and far between, but it can serve.

Note that for the generated code to render well within Emacs, it must be placed in a raw drawer.
The =:wrap= noweb argument should therefore be disabled, which apparently cannot be done at the code block level if it was enabled at the document level.
If that is the case, the only thing to do is to disable it at the section level, by overwriting the property drawer just below the section header like so:
#+begin_src org
,*** Some section
:PROPERTIES:
:header-args:
:END:
#+end_src


* Executable utilities

This section regroups code blocks that can be executed from other org-mode files, using a syntax like this:
#+begin_src cpp :noweb no
<<litlib/cpp.org:code_block_name()>>
#+end_src

Not very useful for now overall, because =include.pl= lacks the functionality to execute code blocks.
# TODO: Add this much-needed functionality. This might prove (very) difficult.

** Special members generation

What is meant by special members are the following elements:
 - Copy constructor.
 - Copy assignment operator.
 - Move constructor.
 - Move assignment operator.
 - Default constructor.
 - Destructor.

#+name: special_members
#+begin_src perl :var args="" :results output
use strict;
use warnings;
use v5.14;
use Text::ParseWords qw/quotewords/;

sub extract_parameters {
    my $parameters_string = shift;
    $parameters_string =~ s/^\s*://
        or die "Parameters string `$parameters_string` does not start with `:`";
    my @parameters = quotewords ':', 1, $parameters_string;
    my %parameters = map {s/\s+$//; my ($h, @t) = quotewords '\s+', 0, $_; $h => \@t}
        @parameters;
    return \%parameters;
}

my %flags = %{extract_parameters $args};

sub take_all {
    my $what = shift;
    return @{ delete($flags{$what}) // []};
}

sub format_array {
    my $array = shift;
    return "[" . join(", ", @$array) . "]";
}

sub take_one {
    my $what = shift;
    my @params = take_all $what;
    die "Precisely one value for :$what is required, got " . format_array(\@params) . "."
        if @params != 1;
    return $params[0];
}

sub present {
    my $what = shift;
    if(defined $flags{$what}) {
        die ":$what is a boolean flag and therefore does not accept any value."
            if @{$flags{$what}} != 0;
        return 1;
    }
    return 0;
}

my $name = take_one('name');
my @default = take_all('default');
my @delete = take_all('delete');

my %shortcuts = (
    'move-only' => [[qw/move move=/], [qw/copy copy= empty/]]
);

my $selected_shortcut;
foreach(keys %shortcuts) {
    if(present $_) {
        die "Cannot use more than one shortcut but :$selected_shortcut and :$_ are present."
            if defined $selected_shortcut;
        $selected_shortcut = $_;
    }
}

if(defined $selected_shortcut) {
    die "Shortcuts are mutually exclusive with :default and :delete."
        if @default != 0 or @delete != 0;
    @default = @{$shortcuts{$selected_shortcut}->[0]};
    @delete  = @{$shortcuts{$selected_shortcut}->[1]};
}

my %signatures = (
    'move'  => "$name($name&&)",
    'move=' => "$name& operator=($name&&)",
    'copy'  => "$name(const $name&)",
    'copy=' => "$name& operator=(const $name&)",
    'empty' => "$name()"
);

die "Nothing to generate, :default and :delete are empty."
    if @default == 0 and @delete == 0;

foreach(@default) {
    die "Invalid default name `$_`."
        if !defined $signatures{$_};
    say $signatures{$_} . '=default;';
}

foreach(@delete) {
    die "Invalid delete name `$_`."
        if !defined $signatures{$_};
    say $signatures{$_} . '=delete;';
}
#+end_src

#+call: special_members(":name vertices :move-only")

#+RESULTS:
#+begin_src text
vertices(vertices&&)=default;
vertices& operator=(vertices&&)=default;
vertices(const vertices&)=delete;
vertices& operator=(const vertices&)=delete;
vertices()=delete;
#+end_src


* Printing

** Type name to string
From https://stackoverflow.com/a/56766138.

#+name: type_str
#+begin_src cpp :noweb-ref litlib
template <typename T>
constexpr auto type_str() noexcept {
    std::string_view name = "Error: unsupported compiler", prefix, suffix;
#ifdef __clang__
    name = __PRETTY_FUNCTION__;
    prefix = "auto type_str() [T = ";
    suffix = "]";
#elif defined(__GNUC__)
    name = __PRETTY_FUNCTION__;
    prefix = "constexpr auto type_str() [with T = ";
    suffix = "]";
#elif defined(_MSC_VER)
    name = __FUNCSIG__;
    prefix = "auto __cdecl type_str<";
    suffix = ">(void) noexcept";
#endif
    name.remove_prefix(prefix.size());
    name.remove_suffix(suffix.size());
    return name;
}
#+end_src
#+depends:type_str :cpp string_view

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb type_str :cpp iostream")>>
using namespace std;
int main(){
    cout << type_str<int>() << "\n";
    const long ft = 42;
    cout << type_str<decltype(ft)>() << "\n";
    cout << type_str<decltype(12.3)>() << "\n";
}
#+end_src

#+RESULTS:
#+begin_src text
int
const long int
double
#+end_src


** Type printer (=print_infos=)

#+name: print_infos
#+begin_src cpp :noweb-ref litlib
template<typename T>
void print_infos() {
    std::cout << type_str<T>() << " -> " << sizeof(T) << " bytes\n";
}
#+end_src
#+depends:print_infos :cpp iostream :noweb type_str

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb print_infos")>>
using namespace std;

int main(){
    print_infos<int>();
    const long ft = 42;
    print_infos<decltype(ft)>();
    print_infos<decltype(12.3)>();
}
#+end_src

#+RESULTS:
#+begin_src text
int -> 4 bytes
const long int -> 8 bytes
double -> 8 bytes
#+end_src


** Container redirection

This =std::ostream= operator overload should be enough to print most array-like types:
#+name: <<span
#+begin_src cpp
template<class T>
std::ostream& operator<<(std::ostream& os, const std::span<T> container) {
    auto it = container.begin();
    os << "[";
    if(container.size() > 0) {
        os << *it;
        for(++it; it != container.end(); ++it)
            os << ", " << *it;
    }
    os << "]";
    return os;
}
#+end_src
#+depends:<<span :cpp span iostream

For reasons beyond my C++ knowledge, using =const std::span<const T>= instead of ==const std::span<T>== results in a compilation error in some cases.

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb <<span :cpp iostream vector span")>>
int main() {
    int lost_carray[] {4, 8, 15, 16, 23, 42};
    std::vector<int> lost_vector{4, 8, 15, 16, 23, 42};
    std::cout << lost_carray << "\n";
    std::cout << std::span(lost_carray, 6) << "\n";
    std::cout << std::span(lost_vector) << "\n";
}
#+end_src

#+RESULTS:
#+begin_src text
0x7fff98b7fec0
[4, 8, 15, 16, 23, 42]
[4, 8, 15, 16, 23, 42]
#+end_src

Trying to directly print the array only prints the address of its first element, as should be expected.
To really print the array, it must be wrapped explicitely in =std::span=.
I'll probably write shortcuts for =std::vector= and =std::array= when I need them.


** Print function

With variadic template and a bit of constructor abuse, it's possible to make a python-style print function accepting any number of arguments, separating them with a space and printing a newline at the end.
What I mean by constructor abuse is that the constructor just below is not really here to construct anything, it is simply the mechanism allowing us to use the =print= struct like a function.
It's only here to trigger the side-effect.

#+name: print-function
#+begin_src cpp :noweb-ref litlib
namespace print_{
struct err {
    constexpr static auto& value = std::cerr;
};

struct out {
    constexpr static auto& value = std::cout;
};

struct format {
    std::string sep = " ";
    std::string end = "\n";
};

}

template<typename Destination=print_::out>
struct print {
  private:
    template<typename T>
    void print_one(const T& el) {
        Destination::value << el;
    }

    template<typename T>
    void print_all(const T& el) { // Last.
        Destination::value << el << format_.end;
    }

    template<typename T, typename... Args>
    void print_all(const T& el, Args... args) {
        print_one(el);
        print_one(format_.sep);
        print_all(args...);
    }

    print_::format format_ = print_::format();

  public:
    // Default formatting.
    template<typename... Args>
    print(Args... args) {
        print_all(args...);
    }

    <<print-function/public>>
};
#+end_src
#+depends:print-function :cpp iostream

Printing to stderr is a bit weird to test because org-mode simply does not display stderr and I do not know how to fix this.

#+begin_src cpp :eval no-export :exports both
<<include(":noweb print-function")>>
using namespace print_;

int main(){
    print<err>{"will", "not", "print"};
    print{"will print", "this", "one", 1, 47.2};
}
#+end_src

#+RESULTS:
#+begin_src text
will print this one 1 47.2
#+end_src

*** Empty line

Adding a default constructor will allow the caller to print empty lines, which is something I like to do from time to time when I want to let the output breathe.

#+begin_src cpp :noweb-ref print-function/public
print() {
    Destination::value << format_.end;
}
#+end_src

*** Customizable formatting

To make the separator and the end delimiter customizable, a bit more magic is needed in the form of a =printer::format= constructor and a parentheses operator.
#+begin_src cpp :noweb-ref print-function/public
print(print_::format fmt): format_(std::move(fmt))
{}

template<typename... Args>
void operator()(Args... args) {
    print_all(args...);
}
#+end_src

Now it's possible to customize the print "function" by first constructing it with a =printer::format= and then using its parentheses operator to print stuff.

#+begin_src cpp :eval no-export :exports both
<<include(":noweb print-function")>>

int main() {
    print{{.sep=" -> ", .end=", this is the end.\n"}}(1, "two", int(7.5 -4), 2. * 2);
}
#+end_src

#+RESULTS:
#+begin_src text
1 -> two -> 3 -> 4, this is the end.
#+end_src

Apparently this src_cpp[]{{.field1=value1, .field2=value2}} syntax is called designated initialization.

Some added bonuses:
 1. It's possible to construct a printer object and to reuse it at will.
 2. The formatting parameters can also be used individually.

#+begin_src cpp :eval no-export :exports both
<<include(":noweb print-function")>>

int main() {
    auto printer = print{{.sep=" < "}};
    printer(4, 8, 15, 16, 23, 42);
    printer("lost", "stargate");
    print{};
    print{{.end=" it's me Imoen"}}("heya");
}
#+end_src

#+RESULTS:
#+begin_src text
4 < 8 < 15 < 16 < 23 < 42
lost < stargate

heya it's me Imoen
#+end_src

Some disadvantages:
 1. The double braced syntax is a bit wonky.
 2. Parameters must be in the correct order, src_cpp[]{print{{.end="\n", .sep=", "}}("test");} will not compile.
 3. It's possible to make an incorrect call by mistake without it triggering a compilation error.
    #+begin_src cpp :eval no-export :exports both
<<include(":noweb print-function")>>
int main() {
    print{.sep=", ", .end="\n"}("test");
}
    #+end_src

    #+RESULTS:
    #+begin_src text
    ,  

    test
    #+end_src
    I don't know why this is allowed but it evidently is.

 4. The syntax is inconsistent because for some reason I don't understand, src_cpp[]{std::string a("3"); print(a);} does not compile, whereas src_cpp[]{std::string a("3"); print{a});} does.

    So my guideline would be to use braces when using the default formatting and parens when using custom formatting.


** Log function calls

The goal here is to make a tool that will make it easy to log the function calls being done, for debugging purposes.
Since this tool was a bit complex to put in place, some implementation details have been hidden inside the namespace =details=:
#+begin_src cpp :noweb-ref log_call
namespace details {
<<details/log_call>>
}
#+end_src
#+depends:log_call :cpp string iostream

*** Arguments logging

Most arguments are logged as-is, except for strings which are enclosed in quote, to make things more readable.
#+begin_src cpp :noweb-ref details/log_call
template<typename T>
void log_one_argument(const T& arg) {
    std::cout << arg;
}

void log_one_argument(const char* arg) {
    std::cout << '"' << arg << '"';
}

void log_one_argument(const std::string& arg) {
    log_one_argument(arg.c_str());
}
#+end_src

The heavy lifting of arguments logging is done by the three function below, who respectively handle the case where no arguments are left, the case where one argument is left and the case where more than one argument is left.
In essence, a call to =log_call_arguments= is resolved with recursive calls to the last function, which progressively consumes the =tail= and the other function are special cases to tidy up the output.
#+begin_src cpp :noweb-ref details/log_call
void log_call_arguments() {
    std::cout << ");\n";
}

template<typename T>
void log_call_arguments(const T& last) {
    log_one_argument(last);
    log_call_arguments();
}

template<typename T, typename... Args>
void log_call_arguments(const T& head, Args... tail) {
    log_one_argument(head);
    std::cout << ", ";
    log_call_arguments(tail...);
}
#+end_src

*** =log_call=

Most of what is needed to log simple function calls is handled by =log_call_arguments=, only the function name and the opening paren is missing:
#+begin_src cpp :noweb-ref log_call
template<typename... Args>
void log_call(const char* function_name, Args... args) {
    std::cout << "-> " << function_name << '(';
    details::log_call_arguments(args...);
}
#+end_src

In practice, using this function looks like this:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb log_call")>>

int main() {
    auto sixteen = 16;
    auto twenty_three = 23;
    const char* forty_two = "forty two";
    log_call("log_call", 4, 8, 15, sixteen, twenty_three, forty_two, std::string("string"));
}
#+end_src

#+RESULTS:
#+begin_src text
-> log_call(4, 8, 15, 16, 23, "forty two", "string");
#+end_src

*** Macro

This very handy macro can be used to both log and then call a function:
#+begin_src cpp :noweb-ref log_call
#define LOG_AND_CALL(function, ...) log_call(#function, __VA_ARGS__); function(__VA_ARGS__);
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb log_call")>>

void hello(const std::string& message) {
    std::cout << "hello, " << message << "\n";
}

int main() {
    LOG_AND_CALL(hello, "universe!")
}
#+end_src

#+RESULTS:
#+begin_src text
-> hello("universe!");
hello, universe!
#+end_src


* Various utilities

This section is dedicated to utilities without overarching themes.

** Sum of a container

I didn't like the idea of using =std::accumulate= with a begin iterator, a end iterator and a mandatory neutral element, so I made the =sum= template for a more Python-like experience.

I also didn't like the fact that using =std::accumulate= specifically for this it adds a dependency.
Limiting dependencies is crucial to LitLib's developpement style since everything needs to be recompiled everytime.

#+name: sum
#+begin_src cpp
template<class Container>
typename Container::value_type sum(const Container& source, typename Container::value_type neutral=0) {
    for(const auto& el: source)
        neutral += el;
    return neutral;
}
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb sum print-function :cpp vector array span")>>

int main() {
    std::vector<int> lost_v{4, 8, 15, 16, 23, 42};
    std::array<int, 6> lost_a{4, 8, 15, 16, 23, 42};
    std::span<int> lost_s(lost_v);
    print{"Sum of lost numbers with a std::vector:", sum(lost_v)};
    print{"Same thing with a std::array:", sum(lost_a)};
    print{"Same thing with a std::span:", sum(lost_s)};
}
#+end_src

#+RESULTS:
#+begin_src text
Sum of lost numbers with a std::vector: 108
Same thing with a std::array: 108
Same thing with a std::span: 108
#+end_src
\\

This template does not work directly with C arrays but wrapping them in =std::span= makes it work:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb sum print-function :cpp span")>>
int main() {
    float lost[]{4, 8, 15, 16, 23, 42};
    print{"Sum of lost numbers with a C array, via std::span:", sum(std::span(lost))};
}
#+end_src

#+RESULTS:
#+begin_src text
Sum of lost numbers with a C array, via std::span: 108
#+end_src


* Cool tricks (don't try this at home)

This section is dedicated to weird C++ voltige.
It might be dangerous, useless or plain stupid but it is (subjectively) always interesting and can raise new way to abuse the language.

** Mandatory keyword arguments

Designated initialisers in C++20 enable a syntax reminiscent to Python keyword arguments, although more verbose and limited.
A problem is that there is, to my knowledge, no built-in way to specify that a keyword argument is mandatory.

Let's use the example of the following =user= class:
#+name: example-mandatory-user
#+begin_src cpp
class user {
  public:
    struct keyword_arguments {
        std::string group = "others";
        std::string name;
        unsigned long id;
    };
    user(keyword_arguments&& kwargs):
        group_(std::move(kwargs.group)),
        name_(std::move(kwargs.name)),
        id_(kwargs.id)
    {
        print{"group:", group_};
        print{"name:", name_};
        print{"id:", id_};
    }

  private:
    std::string group_, name_;
    unsigned long id_;
};
#+end_src
#+depends:example-mandatory-user :noweb print-function :cpp string

In the following executable, since nothing has been defined for =name= and =id=, the default value for =string= and =unsigned int= are used instead.
This code is perfectly valid, it compiles and executes without problem.
#+begin_src cpp :eval no-export :flags -Wall -std=c++20 :noweb no-export :exports both :minipage
<<include(":noweb example-mandatory-user")>>

int main() {
    user richard({});
}
#+end_src

#+RESULTS:
#+begin_src text
group: others
name: 
id: 0
#+end_src

To force an error when =name= and =id= are not defined, the =mandatory= template can be used.
#+name: mandatory
#+begin_src cpp :minipage
template<typename T>
class mandatory {
  public:
    template<typename... Args>
    mandatory(Args&&... args): value_(std::forward<Args>(args)...)
    {}
    mandatory()=delete;

    const T& operator*() const {return value_;}
    T& operator*() {return value_;}

  private:
    T value_;
};
#+end_src

Some remarks about =mandatory=:
 - The trick is that since the default constructor is deleted, fields wrapped in =mandatory= cannot be silently given a default value.
 - The variadic-template-forwarding constructor gives some flexibility to the way arguments can be assigned.
   In particular without it =std::string= assignments like ={.name = "ricardo"}= fail silently because, I assume, C++ then considers =.name= to be a =char *=.
 - The =*= operator must be used to extract the value since I did not managed to make a working =T= conversion operator.
   I assume move operations performed on the references returned by this operator will work as expected but I'm way out of my knowledge zone.
\\

Beyond declaring =name= and =id= as mandatory fields, this is not fully transparent as some adaptation to the =user= class is required, in the form of putting an asterisk in front of the mandatory arguments when they are used:
#+name: example-mandatory-user-fixed
#+begin_src cpp
class user {
  public:
    struct keyword_arguments {
        std::string group = "others";
        mandatory<std::string> name;
        mandatory<unsigned long> id;
    };
    user(keyword_arguments&& kwargs):
        group_(std::move(kwargs.group)),
        name_(std::move(*kwargs.name)),
        id_(*kwargs.id)
    {
        print{"group:", group_};
        print{"name:", name_};
        print{"id:", id_};
    }

  private:
    std::string group_, name_;
    unsigned long id_;
};
#+end_src
#+depends:example-mandatory-user-fixed :noweb mandatory print-function :cpp string

Now the following code does not compile:
#+begin_src cpp :eval no-export :flags -Wall -std=c++20 :noweb no-export :minipage
<<include(":noweb example-mandatory-user-fixed")>>

int main() {
    user richard({});
}
#+end_src

I am instead greeted by the following error messages:
#+begin_src default
/tmp/babel-QfQ93l/C-src-wPBlHJ.cpp: In function ‘int main()’:
/tmp/babel-QfQ93l/C-src-wPBlHJ.cpp:104:20: error: use of deleted function ‘mandatory<T>::mandatory() [with T = std::__cxx11::basic_string<char>]’
  104 |     user richard({});
      |                    ^
/tmp/babel-QfQ93l/C-src-wPBlHJ.cpp:16:5: note: declared here
   16 |     mandatory()=delete;
      |     ^~~~~~~~~
/tmp/babel-QfQ93l/C-src-wPBlHJ.cpp:104:20: error: use of deleted function ‘mandatory<T>::mandatory() [with T = long unsigned int]’
  104 |     user richard({});
      |                    ^
/tmp/babel-QfQ93l/C-src-wPBlHJ.cpp:16:5: note: declared here
   16 |     mandatory()=delete;
      |     ^~~~~~~~~
#+end_src
Which are surprisingly appropriate, I am pleasantly surprised.

If only one mandatory argument is supplied, a compilation error is also triggered for the missing field.
On the other hand, the following code works as expected:
#+begin_src cpp :eval no-export :flags -Wall -std=c++20 :noweb no-export :exports both :minipage
<<include(":noweb example-mandatory-user-fixed")>>

int main() {
    user richard({.name = "ricardo", .id = 4815162342});
}
#+end_src

#+RESULTS:
#+begin_src text
group: others
name: ricardo
id: 4815162342
#+end_src
