#+PROPERTY: header-args:cpp :eval never :main no :flags -Wall -std=c++20 :noweb no-export
#+PROPERTY: header-args :exports both :wrap "src text"

#+title: LitLib C++
#+subtitle: A collection of C++20 building blocks for literate programming

* Prelude

Mandatory include block to be able to execute examples:
#+name: include
#+begin_src sh :var args="" :results output :wrap "src cpp"
./include.pl "cpp.org" "$args"
#+end_src

* Executable utilities

This section regroups code blocks that can be executed from other org-mode files, using a syntax like this:
#+begin_src cpp :noweb no
<<litlib/cpp.org:code_block_name()>>
#+end_src

Not very useful for now overall, because =include.pl= lacks the functionality to execute code blocks.
# TODO: Add this much-needed functionality. This might prove (very) difficult.

** Special members generation

What is meant by special members are the following elements:
 - Copy constructor.
 - Copy assignment operator.
 - Move constructor.
 - Move assignment operator.
 - Default constructor.
 - Destructor.

#+name: special_members
#+begin_src perl :var args="" :results output
use strict;
use warnings;
use v5.14;
use Text::ParseWords qw/quotewords/;

sub extract_parameters {
    my $parameters_string = shift;
    $parameters_string =~ s/^\s*://
        or die "Parameters string `$parameters_string` does not start with `:`";
    my @parameters = quotewords ':', 1, $parameters_string;
    my %parameters = map {s/\s+$//; my ($h, @t) = quotewords '\s+', 0, $_; $h => \@t}
        @parameters;
    return \%parameters;
}

my %flags = %{extract_parameters $args};

sub take_all {
    my $what = shift;
    return @{ delete($flags{$what}) // []};
}

sub format_array {
    my $array = shift;
    return "[" . join(", ", @$array) . "]";
}

sub take_one {
    my $what = shift;
    my @params = take_all $what;
    die "Precisely one value for :$what is required, got " . format_array(\@params) . "."
        if @params != 1;
    return $params[0];
}

sub present {
    my $what = shift;
    if(defined $flags{$what}) {
        die ":$what is a boolean flag and therefore does not accept any value."
            if @{$flags{$what}} != 0;
        return 1;
    }
    return 0;
}

my $name = take_one('name');
my @default = take_all('default');
my @delete = take_all('delete');

my %shortcuts = (
    'move-only' => [[qw/move move=/], [qw/copy copy= empty/]]
);

my $selected_shortcut;
foreach(keys %shortcuts) {
    if(present $_) {
        die "Cannot use more than one shortcut but :$selected_shortcut and :$_ are present."
            if defined $selected_shortcut;
        $selected_shortcut = $_;
    }
}

if(defined $selected_shortcut) {
    die "Shortcuts are mutually exclusive with :default and :delete."
        if @default != 0 or @delete != 0;
    @default = @{$shortcuts{$selected_shortcut}->[0]};
    @delete  = @{$shortcuts{$selected_shortcut}->[1]};
}

my %signatures = (
    'move'  => "$name($name&&)",
    'move=' => "$name& operator=($name&&)",
    'copy'  => "$name(const $name&)",
    'copy=' => "$name& operator=(const $name&)",
    'empty' => "$name()"
);

die "Nothing to generate, :default and :delete are empty."
    if @default == 0 and @delete == 0;

foreach(@default) {
    die "Invalid default name `$_`."
        if !defined $signatures{$_};
    say $signatures{$_} . '=default;';
}

foreach(@delete) {
    die "Invalid delete name `$_`."
        if !defined $signatures{$_};
    say $signatures{$_} . '=delete;';
}
#+end_src

#+call: special_members(":name vertices :move-only")

#+RESULTS:
#+begin_src text
vertices(vertices&&)=default;
vertices& operator=(vertices&&)=default;
vertices(const vertices&)=delete;
vertices& operator=(const vertices&)=delete;
vertices()=delete;
#+end_src

* Printing

** Type name to string
From https://stackoverflow.com/a/56766138.

#+name: type_str
#+begin_src cpp :noweb-ref litlib
template <typename T>
constexpr auto type_str() noexcept {
    std::string_view name = "Error: unsupported compiler", prefix, suffix;
#ifdef __clang__
    name = __PRETTY_FUNCTION__;
    prefix = "auto type_str() [T = ";
    suffix = "]";
#elif defined(__GNUC__)
    name = __PRETTY_FUNCTION__;
    prefix = "constexpr auto type_str() [with T = ";
    suffix = "]";
#elif defined(_MSC_VER)
    name = __FUNCSIG__;
    prefix = "auto __cdecl type_str<";
    suffix = ">(void) noexcept";
#endif
    name.remove_prefix(prefix.size());
    name.remove_suffix(suffix.size());
    return name;
}
#+end_src
#+depends:type_str :cpp string_view

Usage:
#+begin_src cpp :eval no-export
<<include(":noweb type_str :cpp iostream")>>
using namespace std;
int main(){
    cout << type_str<int>() << "\n";
    const long ft = 42;
    cout << type_str<decltype(ft)>() << "\n";
    cout << type_str<decltype(12.3)>() << "\n";
}
#+end_src

#+RESULTS:
#+begin_src text
int
const long int
double
#+end_src


** Type printer (=print_infos=)

#+name: print_infos
#+begin_src cpp :noweb-ref litlib
template<typename T>
void print_infos() {
    std::cout << type_str<T>() << " -> " << sizeof(T) << " bytes\n";
}
#+end_src
#+depends:print_infos :cpp iostream :noweb type_str

Usage:
#+begin_src cpp :eval no-export
<<include(":noweb print_infos")>>
using namespace std;

int main(){
    print_infos<int>();
    const long ft = 42;
    print_infos<decltype(ft)>();
    print_infos<decltype(12.3)>();
}
#+end_src

#+RESULTS:
#+begin_src text
int -> 4 bytes
const long int -> 8 bytes
double -> 8 bytes
#+end_src


** Print function

With variadic template and a bit of constructor abuse, it's possible to make a python-style print function accepting any number of arguments, separating them with a space and printing a newline at the end.
What I mean by constructor abuse is that the constructor just below is not really here to construct anything, it is simply the mechanism allowing us to use the =print= struct like a function.
It's only here to trigger the side-effect.

#+name: print-function
#+begin_src cpp :noweb-ref litlib
namespace print_{
struct err {
    constexpr static auto& value = std::cerr;
};

struct out {
    constexpr static auto& value = std::cout;
};

struct format {
    std::string sep = " ";
    std::string end = "\n";
};

}

template<typename Destination=print_::out>
struct print {
  private:
    template<typename T>
    void print_one(const T& el) {
        Destination::value << el;
    }

    template<typename T>
    void print_all(const T& el) { // Last.
        Destination::value << el << format_.end;
    }

    template<typename T, typename... Args>
    void print_all(const T& el, Args... args) {
        print_one(el);
        print_one(format_.sep);
        print_all(args...);
    }

    print_::format format_ = print_::format();

  public:
    // Default formatting.
    template<typename... Args>
    print(Args... args) {
        print_all(args...);
    }

    <<print-function/public>>
};
#+end_src
#+depends:print-function :cpp iostream

Printing to stderr is a bit weird to test because org-mode simply does not display stderr and I do not know how to fix this.

#+begin_src cpp :eval no-export
<<include(":noweb print-function")>>
using namespace print_;

int main(){
    print<err>{"will", "not", "print"};
    print{"will print", "this", "one", 1, 47.2};
}
#+end_src

#+RESULTS:
#+begin_src text
will print this one 1 47.2
#+end_src

*** Empty line

Adding a default constructor will allow the caller to print empty lines, which is something I like to do from time to time when I want to let the output breathe.

#+begin_src cpp :noweb-ref print-function/public
print() {
    Destination::value << format_.end;
}
#+end_src

*** Customizable formatting

To make the separator and the end delimiter customizable, a bit more magic is needed in the form of a =printer::format= constructor and a parentheses operator.
#+begin_src cpp :noweb-ref print-function/public
print(print_::format fmt): format_(std::move(fmt))
{}

template<typename... Args>
void operator()(Args... args) {
    print_all(args...);
}
#+end_src

Now it's possible to customize the print "function" by first constructing it with a =printer::format= and then using its parentheses operator to print stuff.

#+begin_src cpp :eval no-export
<<include(":noweb print-function")>>

int main() {
    print{{.sep=" -> ", .end=", this is the end.\n"}}(1, "two", int(7.5 -4), 2. * 2);
}
#+end_src

#+RESULTS:
#+begin_src text
1 -> two -> 3 -> 4, this is the end.
#+end_src

Apparently this src_cpp[]{{.field1=value1, .field2=value2}} syntax is called designated initialization.

Some added bonuses:
 1. It's possible to construct a printer object and to reuse it at will.
 2. The formatting parameters can also be used individually.

#+begin_src cpp :eval no-export
<<include(":noweb print-function")>>

int main() {
    auto printer = print{{.sep=" < "}};
    printer(4, 8, 15, 16, 23, 42);
    printer("lost", "stargate");
    print{};
    print{{.end=" it's me Imoen"}}("heya");
}
#+end_src

#+RESULTS:
#+begin_src text
4 < 8 < 15 < 16 < 23 < 42
lost < stargate

heya it's me Imoen
#+end_src

Some disadvantages:
 1. The double braced syntax is a bit wonky.
 2. Parameters must be in the correct order, src_cpp[]{print{{.end="\n", .sep=", "}}("test");} will not compile.
 3. It's possible to make an incorrect call by mistake without it triggering a compilation error.
    #+begin_src cpp :eval no-export
<<include(":noweb print-function")>>
int main() {
    print{.sep=", ", .end="\n"}("test");
}
    #+end_src

    #+RESULTS:
    #+begin_src text
    ,  

    test
    #+end_src
    I don't know why this is allowed but it evidently is.

 4. The syntax is inconsistent because for some reason I don't understand, src_cpp[]{std::string a("3"); print(a);} does not compile, whereas src_cpp[]{std::string a("3"); print{a});} does.

    So my guideline would be to use braces when using the default formatting and parens when using custom formatting.


** Log function calls

The goal here is to make a tool that will make it easy to log the function calls being done, for debugging purposes.
Since this tool was a bit complex to put in place, some implementation details have been hidden inside the namespace =details=:
#+begin_src cpp :noweb-ref log_call
namespace details {
<<details/log_call>>
}
#+end_src
#+depends:log_call :cpp string iostream

*** Arguments logging

Most arguments are logged as-is, except for strings which are enclosed in quote, to make things more readable.
#+begin_src cpp :noweb-ref details/log_call
template<typename T>
void log_one_argument(const T& arg) {
    std::cout << arg;
}

void log_one_argument(const char* arg) {
    std::cout << '"' << arg << '"';
}

void log_one_argument(const std::string& arg) {
    log_one_argument(arg.c_str());
}
#+end_src

The heavy lifting of arguments logging is done by the three function below, who respectively handle the case where no arguments are left, the case where one argument is left and the case where more than one argument is left.
In essence, a call to =log_call_arguments= is resolved with recursive calls to the last function, which progressively consumes the =tail= and the other function are special cases to tidy up the output.
#+begin_src cpp :noweb-ref details/log_call
void log_call_arguments() {
    std::cout << ");\n";
}

template<typename T>
void log_call_arguments(const T& last) {
    log_one_argument(last);
    log_call_arguments();
}

template<typename T, typename... Args>
void log_call_arguments(const T& head, Args... tail) {
    log_one_argument(head);
    std::cout << ", ";
    log_call_arguments(tail...);
}
#+end_src

*** =log_call=

Most of what is needed to log simple function calls is handled by =log_call_arguments=, only the function name and the opening paren is missing:
#+begin_src cpp :noweb-ref log_call
template<typename... Args>
void log_call(const char* function_name, Args... args) {
    std::cout << "-> " << function_name << '(';
    details::log_call_arguments(args...);
}
#+end_src

In practice, using this function looks like this:
#+begin_src cpp :eval no-export
<<include(":noweb log_call")>>

int main() {
    auto sixteen = 16;
    auto twenty_three = 23;
    const char* forty_two = "forty two";
    log_call("log_call", 4, 8, 15, sixteen, twenty_three, forty_two, std::string("string"));
}
#+end_src

#+RESULTS:
#+begin_src text
log_call(4, 8, 15, 16, 23, "forty two", "string");
#+end_src

*** Macro

This very handy macro can be used to both log and then call a function:
#+begin_src cpp :noweb-ref log_call
#define LOG_AND_CALL(function, ...) log_call(#function, __VA_ARGS__); function(__VA_ARGS__);
#+end_src

Usage example:
#+begin_src cpp :eval no-export
<<include(":noweb log_call")>>

void hello(const std::string& message) {
    std::cout << "hello, " << message << "\n";
}

int main() {
    LOG_AND_CALL(hello, "universe!")
}
#+end_src

#+RESULTS:
#+begin_src text
-> hello("universe!");
hello, universe!
#+end_src
