#+title: LitLib C++
#+subtitle: A collection of C++20 building blocks for literate programming
#+author: mooss

#+property: header-args:cpp :eval never :main no :flags -std=c++20 -Wall -Werror :noweb no-export :wrap "src text :minipage"
#+property: header-args:bash :noweb no-export
#+options: ^:nil

* Prelude

** Include script

Mandatory include block to be able to execute examples:
#+name: include
#+begin_src sh :var args="" :results output :wrap "src cpp"
./include.pl "cpp.org" "$args"
#+end_src


** Generic include script

Like =include= above, but without predefined values.
#+name: generic-include
#+begin_src bash :var sources="" args=""
./include.pl "$sources" "$args"
#+end_src


* Code generation
:PROPERTIES:
:header-args:
:END:

** =Pycgen= and =Pyogen=

The class =Pycgen= (Python C++ generator) uses the concept of context managers to help with the task of generating C++ code in python.
# {
#+name: Pycgen
#+begin_src python
class Pycgen:
    def __init__(self, indent_str='    ', level=0):
        self.indent_str = indent_str
        self.level = level
        self.close = []

    def __enter__(self):
        self.level += 1
        if len(self.close) < self.level:
            self.close.append('')

    def __exit__(self, ex_type, ex_value, traceback):
        self.level -= 1
        self.indent(self.close.pop())

    def __call__(self, *lines):
        for line in lines:
            self.indent(line)

    def indent(self, line):
        print(self.indent_str * self.level, end='')
        print(line)

    def par(self, line, open='{', close='}'):
        self(line + ' ' + open)
        self.close.append(close)
        return self

    def struct(self, name):
        return self.par('struct ' + name, close='};')
#+end_src

In a similar vein, =Pyogen= can generate org-mode code blocks, with support for LitLib =#+depends= syntax.
#+name: Pyogen
#+begin_src python
class Pyogen:
    def __init__(self, what, name=None, depends=None):
        if depends is not None: assert name is not None
        what = what.split(' ', maxsplit=1)
        self.first = what[0]
        if len(what) == 2:
            self.rest = ' ' + what[1]
        else:
            self.rest = ''
        self.name = name
        self.depends = depends

    def __enter__(self):
        if self.name is not None:
            print('#+name:', self.name)
        print('#+begin_' + self.first + self.rest)

    def __exit__(self, ex_type, ex_value, traceback):
        print('#+end_' + self.first)
        if self.depends is not None:
            print('#+depends:' + self.name + ' ' + self.depends)
#+end_src

Here is the hello world of =Pyogen= and =Pycgen=:
#+begin_src python :noweb no-export :results output :exports both
<<include(":noweb Pyogen Pycgen")>>
cpp = Pycgen()
with Pyogen('src cpp', name='Pyogen-hw', depends=':cpp iostream'):
    with cpp.par('void hello_world()'):
        cpp('std::cout << "Hello, world!\\n";')
#+end_src

#+RESULTS:
:results:
#+name: Pyogen-hw
#+begin_src cpp
void hello_world() {
    std::cout << "Hello, world!\n";
}
#+end_src
#+depends:Pyogen-hw :cpp iostream
:end:

This generated code can be used elsewhere in the document, like so:
#+begin_src cpp :eval no-export :wrap "src text" :exports both
<<include(":noweb Pyogen-hw")>>
int main() {
    hello_world();
}
#+end_src

#+RESULTS:
#+begin_src text
Hello, world!
#+end_src

This so-called code generation is more of an amusement that a serious endeavour, the situations where it is practical are few and far between, but it can serve.

Note that for the generated code to render well within Emacs, it must be placed in a raw drawer.
The =:wrap= noweb argument should therefore be disabled, which apparently cannot be done at the code block level if it was enabled at the document level.
If that is the case, the only thing to do is to disable it at the section level, by overwriting the property drawer just below the section header like so:
#+begin_src org
,*** Some section
:PROPERTIES:
:header-args:
:END:
#+end_src


** Const and non-const generation

A reccurent source of frustration for me in C++ is the fact that sometimes code must be duplicated to offer a const and non const version of a same function.
This section proposes a very simple syntax to define a const and a non const version of the same function, based on the replacement of two symbols:
| Symbol  | const replacement | non const replacement |
|---------+-------------------+-----------------------|
| *=Q__=* | ="const "=        | =""=                  |
| *=Q_=*  | ="const_"=        | =""=                  |

Tools from =bash.org= are relied upon for the implementation.

Default parameters are defined separately to make them appear before the instantiation of =$noweb= into bash variables:
#+name: gen-qualified-default-params
#+begin_src bash
noweb=":pre Generated :lvl ** :sink $noweb"
#+end_src

Verification of the parameters and of the source:
#+begin_src bash :noweb-ref gen-qualified-impl :minipage
assert_chain valued litlib source name noweb_ref

source_block=$($litlib/include.pl "$source" ":exit-with-error :noweb $name")
assert_no_error "Errors in include script:\n$source_block"
#+end_src
#+depends:gen-qualified-impl :noweb gen-qualified-default-params noweb-suite-impl

=const= and =non_const= are destined to be used as the argument of =cpp= to generate the codeblock and the corresponding subsection, if pertinent:
#+begin_src bash :noweb-ref gen-qualified-impl :minipage
function const() {
    echo "$source_block" | sed -r -e 's/Q__/const /g' -e 's/Q_/const_/g'
}

function non_const() {
    echo "$source_block" | sed -r 's/Q__?//g'
}

if declared cb_args
then # Can be used to apply parameters to the generated code blocks, with ; instead of :.
    cb_args=$(echo " $cb_args" | tr ';' ':')
else
    cb_args=' :minipage'
fi

function cpp() {
    echo; valued lvl && echo "*$lvl =$noweb_ref= $1"; echo
    echo "#+begin_src cpp :noweb-ref $noweb_ref$cb_args"
    $1
    echo "#+end_src"
}
#+end_src

Only the printing remains:
#+begin_src bash :noweb-ref gen-qualified-impl :minipage
valued lvl && valued pre && echo "$lvl $pre"

if declared both
then
    const=1; non_const=1
fi
declared const && cpp const
declared non_const && cpp non_const
true # Might exit with an error otherwise and cancel everything.
#+end_src


The implementation of this feature is splitted between =gen-qualified-impl= and =gen-qualified= because =gen-qualified='s role is to define variables that are local to the current file (=source= and =litlib=).
This way, other files will be able to define their own =gen-qualified= through =gen-qualified-impl=[fn::The notion of file-local named code blocks remains to be implemented in =include.pl=.].

#+Name: gen-qualified
#+begin_src bash :var noweb="" :results raw
noweb=":source cpp.org :litlib . :sink $noweb"
<<generic-include("cpp.org bash.org", ":noweb gen-qualified-impl")>>
#+end_src

# TODO: Implement local code blocks in include.pl, i.e. #+Name: means that the code block is loaded only if it is found in the local files (the first from the file list).
# This will allow to have gen-qualified in other files that include cpp.org without triggering a duplicated code block error.

*** Usage

A block using the =Q__= and =Q_= syntax must be defined:
#+name: qualified-example-impl
#+begin_src cpp
Q__int& Q_get_x() Q__{
    return x;
}
#+end_src


Calling =gen-qualified= with this block as =:name= generates the desired const and non-const versions, using the same =noweb-ref=.
#+Call: gen-qualified(":name qualified-example-impl :lvl *** :pre :both :noweb_ref get_x_example :cb_args ;minipage ;custom-param")

#+RESULTS:

**** =get_x_example= const

#+begin_src cpp :noweb-ref get_x_example :minipage :custom-param
const int& const_get_x() const {
    return x;
}
#+end_src

**** =get_x_example= non_const

#+begin_src cpp :noweb-ref get_x_example :minipage :custom-param
int& get_x() {
    return x;
}
#+end_src


* Executable utilities

This section regroups code blocks that can be executed from other org-mode files, using a syntax like this:
#+begin_src cpp :noweb no
<<litlib/cpp.org:code_block_name()>>
#+end_src

Not very useful for now overall, because =include.pl= lacks the functionality to execute code blocks.
# TODO: Add this much-needed functionality. This might prove (very) difficult.

** Special members generation

What is meant by special members are the following elements:
 - Copy constructor.
 - Copy assignment operator.
 - Move constructor.
 - Move assignment operator.
 - Default constructor.
 - Destructor.

#+name: special_members
#+begin_src perl :var args="" :results output
use strict;
use warnings;
use v5.14;
use Text::ParseWords qw/quotewords/;

sub extract_parameters {
    my $parameters_string = shift;
    $parameters_string =~ s/^\s*://
        or die "Parameters string `$parameters_string` does not start with `:`";
    my @parameters = quotewords ':', 1, $parameters_string;
    my %parameters = map {s/\s+$//; my ($h, @t) = quotewords '\s+', 0, $_; $h => \@t}
        @parameters;
    return \%parameters;
}

my %flags = %{extract_parameters $args};

sub take_all {
    my $what = shift;
    return @{delete($flags{$what}) // []};
}

sub format_array {
    my $array = shift;
    return "[" . join(", ", @$array) . "]";
}

sub take_one {
    my $what = shift;
    my @params = take_all $what;
    die "Precisely one value for :$what is required, got " . format_array(\@params) . "."
        if @params != 1;
    return $params[0];
}

sub present {
    my $what = shift;
    if(defined $flags{$what}) {
        die ":$what is a boolean flag and therefore does not accept any value."
            if @{$flags{$what}} != 0;
        return 1;
    }
    return 0;
}

my $name = take_one('name');
my @default = take_all('default');
my @delete = take_all('delete');

my %shortcuts = (
    'move-only' => [[qw/move move=/], [qw/copy copy= empty/]],
    'all' =>       [[qw/move move= copy copy= empty/], []],
);

my $selected_shortcut;
foreach(keys %shortcuts) {
    if(present $_) {
        die "Cannot use more than one shortcut but :$selected_shortcut and :$_ are present."
            if defined $selected_shortcut;
        $selected_shortcut = $_;
    }
}

if(defined $selected_shortcut) {
    die "Shortcuts are mutually exclusive with :default and :delete."
        if @default != 0 or @delete != 0;
    @default = @{$shortcuts{$selected_shortcut}->[0]};
    @delete  = @{$shortcuts{$selected_shortcut}->[1]};
}

my %signatures = (
    'move'  => "$name($name&&)",
    'move=' => "$name& operator=($name&&)",
    'copy'  => "$name(const $name&)",
    'copy=' => "$name& operator=(const $name&)",
    'empty' => "$name()"
);

die "Nothing to generate, :default and :delete are empty."
    if @default == 0 and @delete == 0;

foreach(@default) {
    die "Invalid default name `$_`."
        if !defined $signatures{$_};
    say $signatures{$_} . '=default;';
}

foreach(@delete) {
    die "Invalid delete name `$_`."
        if !defined $signatures{$_};
    say $signatures{$_} . '=delete;';
}
#+end_src

#+call: special_members(":name vertices :move-only")

#+RESULTS:
:results:
vertices(vertices&&)=default;
vertices& operator=(vertices&&)=default;
vertices(const vertices&)=delete;
vertices& operator=(const vertices&)=delete;
vertices()=delete;
:end:


* Printing

** Type name to string
From https://stackoverflow.com/a/56766138.

#+name: type_str
#+begin_src cpp :minipage
template <typename T>
constexpr auto type_str() noexcept {
    std::string_view name = "Error: unsupported compiler", prefix, suffix;
#ifdef __clang__
    name = __PRETTY_FUNCTION__;
    prefix = "auto type_str() [T = ";
    suffix = "]";
#elif defined(__GNUC__)
    name = __PRETTY_FUNCTION__;
    prefix = "constexpr auto type_str() [with T = ";
    suffix = "]";
#elif defined(_MSC_VER)
    name = __FUNCSIG__;
    prefix = "auto __cdecl type_str<";
    suffix = ">(void) noexcept";
#endif
    name.remove_prefix(prefix.size());
    name.remove_suffix(suffix.size());
    return name;
}
#+end_src
#+depends:type_str :cpp string_view

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb type_str :cpp iostream")>>
using namespace std;
int main(){
    cout << type_str<int>() << "\n";
    const long ft = 42;
    cout << type_str<decltype(ft)>() << "\n";
    cout << type_str<decltype(12.3)>() << "\n";
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
int
const long int
double
#+end_src


** Type printers (=print_type= and =print_size=)

#+name: print_type
#+begin_src cpp :minipage
template<typename T>
void print_type() {
    std::cout << type_str<T>() << '\n';
}
template<typename T>
void print_type(const T&) {
    print_type<T>();
}
#+end_src
#+depends:print_type :noweb type_str :cpp iostream

#+name: print_size
#+begin_src cpp :minipage
template<typename T>
void print_size() {
    std::cout << type_str<T>() << " -> " << sizeof(T) << " bytes (" << sizeof(T) * CHAR_BIT << " bits)\n";
}
template<typename T>
void print_size(const T&) {
    print_size<T>();
}
#+end_src
#+depends:print_size :noweb type_str :cpp iostream climits

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb print_type print_size")>>
using namespace std;

int main(){
    print_type<int>();
    print_type(42);
    print_size<int>();
    const long ft = 42;
    print_size<decltype(ft)>();
    print_size<>(ft);
    print_size<decltype(12.3)>();
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
int
int
int -> 4 bytes (32 bits)
const long int -> 8 bytes (64 bits)
long int -> 8 bytes (64 bits)
double -> 8 bytes (64 bits)
#+end_src

Using a value to print its type removes a potential const qualifier but it's very handy anyway.


** =ostream= redirection overloads

This section overloads ostream's =<<= operator for some types from the standard library.

*** Sequential containers

The code below is an internal helper that prints a given container between square brackets.
This format is a reasonable representation for a sequential container, similar to Python's behaviour.

#+name: sequential_redirection
#+begin_src cpp :minipage
namespace container_redirection {
template<class Container>
std::ostream& sequential(std::ostream& os, const Container& container) {
    auto it = container.begin();
    os << "[";
    if(!container.empty()) {
        os << *it;
        for(++it; it != container.end(); ++it)
            os << ", " << *it;
    }
    os << "]";
    return os;
}
}
#+end_src
#+depends:sequential_redirection :cpp ostream

This helper is then used to quickly define =<<= overloads for some common sequential containers.

#+name: <<forward_list
#+begin_src cpp :minipage
template<typename T, typename Allocator>
std::ostream& operator<<(std::ostream& os, const std::forward_list<T, Allocator>& container) {
    return container_redirection::sequential(os, container);
}
#+end_src
#+depends:<<forward_list :noweb sequential_redirection :cpp ostream forward_list

#+name: <<span
#+begin_src cpp :minipage
template<typename T, std::size_t Extent>
std::ostream& operator<<(std::ostream& os, const std::span<T, Extent>& container) {
    return container_redirection::sequential(os, container);
}
#+end_src
#+depends:<<span :noweb sequential_redirection :cpp ostream span

#+name: <<vector
#+begin_src cpp :minipage
template<class T, class Allocator>
std::ostream& operator<<(std::ostream& os, const std::vector<T, Allocator>& container) {
    return container_redirection::sequential(os, container);
}
#+end_src
#+depends:<<vector :noweb sequential_redirection :cpp ostream vector

#+name: <<array
#+begin_src cpp :minipage
template<class T, std::size_t N>
std::ostream& operator<<(std::ostream& os, const std::array<T, N>& container) {
    return container_redirection::sequential(os, container);
}
#+end_src
#+depends:<<array :noweb sequential_redirection :cpp ostream array

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb <<forward_list <<span <<vector <<array print :cpp forward_list vector array span")>>
int main() {
    print{"1. ||| forward_list |||"};
    std::forward_list<int> lost_list{4, 8, 15, 16, 23, 42};
    print{"lost_list", lost_list};

    print{"\n2. ||| vector |||"};
    std::vector<int> lost_vector{4, 8, 15, 16, 23, 42};
    print{"lost_vector", lost_vector};

    print{"\n3. ||| array |||"};
    std::array<int, 6> lost_array{4, 8, 15, 16, 23, 42};
    print{"lost_array", lost_array};

    print{"\n4. ||| span |||"};
    int lost_carray[] {4, 8, 15, 16, 23, 42};
    print{"lost_carray", lost_carray};
    print{"span(lost_carray)", std::span(lost_carray, 6)};
    print{"span(lost_vector)", std::span(lost_vector)};
    print{"span(lost_array)", std::span(lost_array)};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
1. ||| forward_list |||
lost_list [4, 8, 15, 16, 23, 42]

2. ||| vector |||
lost_vector [4, 8, 15, 16, 23, 42]

3. ||| array |||
lost_array [4, 8, 15, 16, 23, 42]

4. ||| span |||
lost_carray 0x7fff3765b9e0
span(lost_carray) [4, 8, 15, 16, 23, 42]
span(lost_vector) [4, 8, 15, 16, 23, 42]
span(lost_array) [4, 8, 15, 16, 23, 42]
#+end_src

Trying to directly print a C-style array only prints the address of its first element, as should be expected.
To really print the array, it must be wrapped explicitely in =std::span=.

*** Tuples and pairs

This ostream redirection operator for =std::tuple= uses =tuple_redirection_impl= as a closure, allowing it to be applied on all elements of the tuple to print:
#+name: <<tuple
#+begin_src cpp :minipage
struct tuple_redirection_impl {
    std::ostream& os;

    void comma_separated_tail() {}

    template<class Head, class... Tail>
    void comma_separated_tail(const Head& head, const Tail&... tail) {
        os << ", " << head;
        comma_separated_tail(tail...);
    }

    template<class Head, class... Tail>
    void operator()(const Head& head, const Tail&... tail) {
        os << head;
        comma_separated_tail(tail...);
    }

}; // struct tuple_redirection_impl

template<class... Args>
std::ostream& operator<<(std::ostream& os, const std::tuple<Args...>& content) {
    os << '<';
    std::apply(tuple_redirection_impl{os}, content);
    os << '>';
    return os;
}
#+end_src
#+depends:<<tuple :cpp ostream tuple

=std::pair= is easier to deal with:
#+name: <<pair
#+begin_src cpp :minipage
template<class First, class Second>
std::ostream& operator<<(std::ostream& os, const std::pair<First, Second>& content) {
    return os << '<' << content.first << ", " << content.second << '>';
}
#+end_src
#+depends:<<pair :cpp ostream utility

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb print <<tuple <<pair :cpp tuple utility")>>

int main() {
    auto lost = std::make_tuple(4, 8, 15, 16, 23, 42);
    print{lost};
    std::pair<
        std::tuple<int, int, int>,
        std::tuple<int, int, int>
    > lo_st{{4, 8, 15}, {16, 23, 42}};
    print{lo_st};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
<4, 8, 15, 16, 23, 42>
<<4, 8, 15>, <16, 23, 42>>
#+end_src


** Print function

With variadic template and a bit of constructor abuse, it's possible to make a python-style print function accepting any number of arguments, separating them with a space and printing a newline at the end.
What I mean by constructor abuse is that the constructor just below is not really here to construct anything, it is simply the mechanism allowing us to use the =print= struct like a function.
It's only here to trigger the side-effect.

#+name: print
#+begin_src cpp
namespace print_{
struct err {
    constexpr static auto& value = std::cerr;
};

struct out {
    constexpr static auto& value = std::cout;
};

struct format {
    std::string sep = " ";
    std::string end = "\n";
};

}

template<typename Destination=print_::out>
struct print {
  private:
    template<typename T>
    void print_one(const T& el) {
        Destination::value << el;
    }

    template<typename T>
    void print_all(const T& el) { // Last.
        Destination::value << el << format_.end;
    }

    template<typename T, typename... Args>
    void print_all(const T& el, const Args&... args) {
        print_one(el);
        print_one(format_.sep);
        print_all(args...);
    }

    print_::format format_ = print_::format();

  public:
    // Default formatting.
    template<typename... Args>
    print(const Args&... args) {
        print_all(args...);
    }

    <<print/public>>
};
#+end_src
#+depends:print :cpp iostream

Printing to stderr is a bit weird to test because org-mode simply does not display stderr and I do not know how to fix this.

#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb print")>>
using namespace print_;

int main(){
    print<err>{"will", "not", "print"};
    print{"will print", "this", "one", 1, 47.2};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
will print this one 1 47.2
#+end_src

*** Empty line

Adding a default constructor will allow the caller to print empty lines, which is something I like to do from time to time when I want to let the output breathe.

#+begin_src cpp :noweb-ref print/public :minipage
print() {
    Destination::value << format_.end;
}
#+end_src

*** Customizable formatting

To make the separator and the end delimiter customizable, a bit more magic is needed in the form of a =printer::format= constructor and a parentheses operator.
#+begin_src cpp :noweb-ref print/public :minipage
print(print_::format fmt): format_(std::move(fmt))
{}

template<typename... Args>
void operator()(const Args&... args) {
    print_all(args...);
}
#+end_src

Now it's possible to customize the print "function" by first constructing it with a =printer::format= and then using its parentheses operator to print stuff.

#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb print")>>

int main() {
    print{{.sep=" -> ", .end=", this is the end.\n"}}(1, "two", int(7.5 -4), 2. * 2);
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
1 -> two -> 3 -> 4, this is the end.
#+end_src

Apparently this src_cpp[]{{.field1=value1, .field2=value2}} syntax is called designated initialization.

Some added bonuses:
 1. It's possible to construct a printer object and to reuse it at will.
 2. The formatting parameters can also be used individually.

#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb print")>>

int main() {
    auto printer = print{{.sep=" < "}};
    printer(4, 8, 15, 16, 23, 42);
    printer("lost", "stargate");
    print{};
    print{{.end=" it's me Imoen"}}("heya");
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
4 < 8 < 15 < 16 < 23 < 42
lost < stargate

heya it's me Imoen
#+end_src

Some disadvantages:
 1. The double braced syntax is a bit wonky.
 2. Parameters must be in the correct order, the following does not compile:
    #+begin_src cpp
print{{.end="\n", .sep=", "}}("test");
    #+end_src

 3. It's possible to make an incorrect call by mistake without it triggering a compilation error.
    #+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb print")>>
int main() {
    print{.sep=", ", .end="\n"}("test");
}
    #+end_src

    #+RESULTS:
    #+begin_src text :minipage
    ,  

    test
    #+end_src
    I don't know why this is allowed but it evidently is.

 4. The syntax is inconsistent because for some reason I don't understand, the following does not compile:
    #+begin_src cpp
std::string a("3");
print(a);
    #+end_src
    Whereas the following does:
    #+begin_src cpp
std::string a("3");
print{a};
    #+end_src
    So my guideline would be to use braces when using the default formatting and parens when using custom formatting.

*** Shortcuts

A printer without separator or end.
=out(whatever);= behaves the same as =std::cout << whatever;= but I prefer to use the first one.
#+name: out
#+begin_src cpp
print out{{.sep="", .end=""}};
#+end_src
#+depends:out :noweb print


** Log function calls

The goal here is to make a tool that will make it easy to log the function calls being done, for debugging purposes.
Since this tool was a bit complex to put in place, some implementation details have been hidden inside the namespace =details=:
#+begin_src cpp :noweb-ref log_call :minipage
namespace details {
<<details/log_call>>
}
#+end_src
#+depends:log_call :cpp string iostream

*** Arguments logging

Most arguments are logged as-is, except for strings which are enclosed in quote, to make things more readable.
#+begin_src cpp :noweb-ref details/log_call :minipage
template<typename T>
void log_one_argument(const T& arg) {
    std::cout << arg;
}

void log_one_argument(const char* arg) {
    std::cout << '"' << arg << '"';
}

void log_one_argument(const std::string& arg) {
    log_one_argument(arg.c_str());
}
#+end_src

The heavy lifting of arguments logging is done by the three function below, who respectively handle the case where no arguments are left, the case where one argument is left and the case where more than one argument is left.
In essence, a call to =log_call_arguments= is resolved with recursive calls to the last function, which progressively consumes the =tail= and the other function are special cases to tidy up the output.
#+begin_src cpp :noweb-ref details/log_call :minipage
void log_call_arguments() {
    std::cout << ");\n";
}

template<typename T>
void log_call_arguments(const T& last) {
    log_one_argument(last);
    log_call_arguments();
}

template<typename T, typename... Args>
void log_call_arguments(const T& head, const Args&... tail) {
    log_one_argument(head);
    std::cout << ", ";
    log_call_arguments(tail...);
}
#+end_src

*** =log_call=

Most of what is needed to log simple function calls is handled by =log_call_arguments=, only the function name and the opening paren is missing:
#+begin_src cpp :noweb-ref log_call :minipage
template<typename... Args>
void log_call(const char* function_name, const Args&... args) {
    std::cout << "-> " << function_name << '(';
    details::log_call_arguments(args...);
}
#+end_src
# )

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb log_call")>>

int main() {
    auto sixteen = 16;
    auto twenty_three = 23;
    const char* forty_two = "forty two";
    log_call("log_call", 4, 8, 15, sixteen, twenty_three, forty_two, std::string("string"));
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
-> log_call(4, 8, 15, 16, 23, "forty two", "string");
#+end_src

*** Macro

This very handy macro can be used to both log and then call a function:
#+begin_src cpp :noweb-ref log_call :minipage
#define LOG_AND_CALL(function, ...) log_call(#function, __VA_ARGS__); function(__VA_ARGS__);
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb log_call")>>

void hello(const std::string& message) {
    std::cout << "hello, " << message << "\n";
}

int main() {
    LOG_AND_CALL(hello, "universe!")
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
-> hello("universe!");
hello, universe!
#+end_src



* Template metaprogramming

This section contains helpers for doing template metaprogramming.

** Foreach loops
*** On variadic arguments

A variadic foreach is a function applying a given callable to all its other arguments.
I would have prefered to put the lambda as the last argument but I failed to make it work.

#+name: variadic_foreach
#+begin_src cpp :minipage
template<typename Lambda, typename Arg>
void variadic_foreach(Lambda lambda, Arg&& arg) {
    lambda(std::forward<Arg>(arg));
}

template<typename Lambda, typename Arg, typename... Args>
void variadic_foreach(Lambda lambda, Arg&& arg, Args&&... args) {
    variadic_foreach(lambda, std::forward<Arg>(arg));
    variadic_foreach(lambda, std::forward<Args>(args)...);
}
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb variadic_foreach print")>>

int main() {
    variadic_foreach([](auto x) {print{x};}, 4, 8, 15, 16, 23, 42);
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
4
8
15
16
23
42
#+end_src

*** On tuple arguments

This the same thing as =variadic_foreach=, this time with a tuple.
I had to use a universal reference to make the function work with temporary values, like in the usage example.

#+name: foreach_tuple
#+begin_src cpp :minipage
template<std::size_t N, typename Lambda, typename Tuple>
void foreach_tuple_impl(Lambda lambda, Tuple& arg) {
    lambda(std::get<N>(arg));
    if constexpr(N + 1 < std::tuple_size_v<Tuple>) {
        foreach_tuple_impl<N + 1>(lambda, arg);
    }
}

template<typename Lambda, typename Tuple>
void foreach_tuple(Lambda lambda, Tuple&& arguments) {
    foreach_tuple_impl<0>(lambda, arguments);
}
#+end_src
#+depends:foreach_tuple :cpp tuple

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb foreach_tuple print :cpp tuple")>>

int main() {
    foreach_tuple([](auto x) {print{x};}, std::make_tuple(4, 8, 15, 16, 23, 42));
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
4
8
15
16
23
42
#+end_src


** Uniform tuple

A uniform tuple is a tuple whose elements have the same type.
The goal is to provide a shortcut because having to write =tuple<int, int, int, int, int, int>= is much too tedious, error prone and difficult to read when compared to =uniform_tuple<6, int>=.

This solution to define homogeneous tuples of a given size was copied from https://stackoverflow.com/a/38894158.
#+name: uniform_tuple
#+begin_src cpp :minipage
template<size_t I, typename T>
struct uniform_tuple_impl {
    template<typename... Args>
    using type = typename uniform_tuple_impl<I-1, T>::template type<T, Args...>;
};

template<typename T>
struct uniform_tuple_impl<0, T> {
    template<typename... Args>
    using type = std::tuple<Args...>;
};

template<size_t I, typename T>
using uniform_tuple = typename uniform_tuple_impl<I, T>::template type<>;
#+end_src
#+depends:uniform_tuple :cpp tuple

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb foreach_tuple print uniform_tuple :cpp tuple")>>

int main() {
    uniform_tuple<4, float> lostf(4.8, 15.16, 23, 42l);
    foreach_tuple([](auto x) {print{x};}, lostf);
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
4.8
15.16
23
42
#+end_src


** Typelist (=meta::list=)

A typelist does not do anything by itself, it is merely a vessel for its underlying types.
What is important is the tools that can be made around that typelist.

The namespace =meta= will be used throughout this section to give operations on typelists a distinct and memorable name.

#+name: meta::list
#+begin_src cpp :minipage
namespace meta {
template<typename... Types>
struct list {};
} // namespace meta
#+end_src

A metalist can at least be printed, thanks to =print_type=:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb meta::list print_type")>>

int main() {
    print_type<meta::list<int, float>>();
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
meta::list<int, float>
#+end_src

*** Strip template arguments

This utility extracts the template arguments of a templated class into a metalist.
For example, applying it to a =Widget<int, float>= would give a =metalist<int, float>=.

At first, it was to be called =meta::args=, because its fetches the template arguments, but since in practice it removes the enclosing type to replace it with a metalist, calling it =meta::strip= seemed to describe more accurately was is being done here.

#+name: meta::strip
#+begin_src cpp :minipage
namespace meta {
template<typename T>
struct strip_impl;

template<template<typename...> class External, typename... Internal>
struct strip_impl<External<Internal...>> {
    using type = list<Internal...>;
};

template<class External>
using strip = strip_impl<External>::type;
} // namespace meta
#+end_src
#+depends:meta::strip :noweb meta::list

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb meta::strip print_type :cpp vector")>>

int main() {
    print_type<meta::strip<std::vector<int>>>();
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
meta::list<int, std::allocator<int> >
#+end_src

*** Dress a metalist

Dressing is the opposite operation of stripping, it transforms a metalist into the desired type.

#+name: meta::dress
#+begin_src cpp :minipage
namespace meta {
template<template<typename...> class Garment, class Typelist>
struct dress_impl;

template<template<typename...> class Garment, typename... Types>
struct dress_impl<Garment, list<Types...>> {
    using type = Garment<Types...>;
};

template<template<typename...> class Garment, class Typelist>
using dress = dress_impl<Garment, Typelist>::type;
} // namespace meta
#+end_src
#+depends:meta::dress :noweb meta::list

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb meta::strip meta::dress print_type :cpp vector list")>>

int main() {
    using stripped = meta::strip<std::vector<int>>;
    print_type<stripped>();
    print_type<meta::dress<std::list, stripped>>();
    print_type<std::list<int>>();
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
meta::list<int, std::allocator<int> >
std::__cxx11::list<int, std::allocator<int> >
std::__cxx11::list<int, std::allocator<int> >
#+end_src

*** Concatenation

Currently only concatenation of a type and a metalist is implemented.

#+name: meta::cat
#+begin_src cpp :minipage
namespace meta {
template<typename Element, class Typelist>
struct cat_impl;

template<typename Element, typename... Args>
struct cat_impl<Element, list<Args...>> {
    using type = list<Element, Args...>;
};

template<typename Element, typename... Args>
struct cat_impl<list<Args...>, Element> {
    using type = list<Args..., Element>;
};

template<typename Left, typename Right>
using cat = cat_impl<Left, Right>::type;
} // namespace meta
#+end_src
#+depends:meta::cat :noweb meta::list

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb meta::cat meta::strip print_type :cpp vector")>>

int main() {
    print_type<meta::cat<float, meta::strip<std::vector<int>>>>();
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
meta::list<float, int, std::allocator<int> >
#+end_src

*** Reversal

#+name: meta::reverse
#+begin_src cpp
namespace meta {
template<class... Typelist>
struct reverse_impl;

template<class Head>
struct reverse_impl<Head> {
    using type = list<Head>;
};

template<class Head, class...Tail>
struct reverse_impl<Head, Tail...> {
    using type = cat<typename reverse_impl<Tail...>::type, Head>;
};

template<class... Elements>
struct reverse_impl<list<Elements...>> {
    using type = reverse_impl<Elements...>::type;
};

template<class... Elements>
using reverse = reverse_impl<Elements...>::type;
}
#+end_src
#+depends:meta::reverse :noweb meta::list meta::cat

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb out print_type meta::reverse")>>

int main() {
    using reversed = meta::reverse<int, float, char>;
    out("Reversed:   ");
    print_type<reversed>();
    out("Unreversed: ");
    print_type<meta::reverse<reversed>>();
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Reversed:   meta::list<char, float, int>
Unreversed: meta::list<int, float, char>
#+end_src

*** Apply an operation to all the types

This is similar to a =map= function, except that instead of applying a function to every element of a data structure, a template template is applied to every type in the metalist.
The name apply was chosen instead of map to avoid any confusion with a container of types.

#+name: meta::apply
#+begin_src cpp :minipage
namespace meta {
template<template<typename...> class Operation, typename... Types>
struct apply_impl;

template<template<typename...> class Operation, typename T>
struct apply_impl<Operation, T> {
    using type = list<Operation<T>>;
};

template<template<typename...> class Operation, typename Head, typename... Tail>
struct apply_impl<Operation, Head, Tail...> {
    using type = cat<Operation<Head>, typename apply_impl<Operation, Tail...>::type>;
};

template<template<typename...> class Operation, typename... Types>
using apply = apply_impl<Operation, Types...>::type;
} // namespace meta
#+end_src
#+depends:meta::apply :noweb meta::list meta::cat

Usage:
#+begin_src cpp :eval no-export :exports both :minipage :wrap "src default :minipage"
<<include(":noweb meta::apply meta::strip print_type :cpp vector")>>

int main() {
    using stripped = meta::apply<meta::strip, std::vector<int>, std::vector<float>, std::vector<bool>>;
    print_type<stripped>();
}
#+end_src

#+RESULTS:
#+begin_src default :minipage
meta::list<meta::list<int, std::allocator<int> >, meta::list<float, std::allocator<float> >, meta::list<bool, std::allocator<bool> > >
#+end_src

*** Steal typenames

The operation implemented here is called stealing because it is a case of one template template (the stealer) taking for itself the arguments of another template template (the robbed).

#+name: meta::steal
#+begin_src cpp :minipage
namespace meta {
template<template<typename...> class Stealer, class Robbed>
struct steal_impl;

template<
    template<typename...> class Stealer,
    template<typename...> class Robbed,
    typename... Plunder
> struct steal_impl<Stealer, Robbed<Plunder...>> {
    using type = Stealer<Plunder...>;
};

template<template<typename...> class Stealer, class Robbed>
using steal = steal_impl<Stealer, Robbed>::type;
} // namespace meta
#+end_src


Here we can see a cruel =std::list= stealing from a defenceless =std::vector=:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb print_type meta::steal :cpp vector list")>>

int main() {
    print_type<meta::steal<std::list, std::vector<int>>>();
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
std::__cxx11::list<int, std::allocator<int> >
#+end_src
And that, is why no one trusts =std::list=.

Technically this operation has nothing to do in the metalist section because it does not depend on it.
It is nevertheless included here because it is very useful in conjunction with metalist operations, as can be seen in the next section.

*** Steal a list of templated arguments

Stealing a list of arguments is a bit different from stealing only one argument because the list of templates that were stolen must be wrapped into another type.
To stay within the stealing metaphor, this wrapping type is here called a guild.

A kind of template closure is used here to do something looking like a partial application of the =steal= template.
This is done in order to make it possible to apply it, because =apply= expects a template template taking one argument.

#+name: meta::stealall
#+begin_src cpp :minipage
namespace meta {
template<
    template<class...> class Guild,
    template<typename...> class Stealer,
    class... UnsuspectingTargets
>
struct stealall_impl {
    template<class Robbed>
    using stealer_closure = steal<Stealer, Robbed>;

    using stealed_metalist = apply<stealer_closure, UnsuspectingTargets...>;

    using type = dress<Guild, stealed_metalist>;
};

template<
    template<class...> class Guild,
    template<typename...> class Stealer,
    class... UnsuspectingTargets
>
using stealall = stealall_impl<Guild, Stealer, UnsuspectingTargets...>::type;
} // namespace meta
#+end_src
#+depends:meta::stealall :noweb meta::steal meta::apply meta::dress

Usage:
#+begin_src cpp :eval no-export :exports both :minipage :wrap "src default :minipage"
<<include(":noweb print_type meta::stealall :cpp vector list")>>

int main() {
    using stolen_vector = meta::stealall<
        std::tuple, std::list,
        std::vector<int>, std::vector<float>, std::vector<bool>
    >;
    print_type<stolen_vector>();
}
#+end_src

#+RESULTS:
#+begin_src default :minipage
std::tuple<std::__cxx11::list<int, std::allocator<int> >, std::__cxx11::list<float, std::allocator<float> >, std::__cxx11::list<bool, std::allocator<bool> > >
#+end_src


** Non-type list

I didn't think about the fact that types and non-types are not compatibles in templates.
As a quick fix for what I needed, I simply adapted =meta::steal= and =meta::stealall= for non-types, by replacing =typename= with =auto= and by adding a =_auto= suffix where appropriate.

#+name: meta::stealall_auto
#+begin_src cpp
namespace meta {
template<template<auto...> class Stealer, class Robbed>
struct steal_auto_impl;

template<
    template<auto...> class Stealer,
    template<auto...> class Robbed,
    auto... Plunder
> struct steal_auto_impl<Stealer, Robbed<Plunder...>> {
    using type = Stealer<Plunder...>;
};

template<template<auto...> class Stealer, class Robbed>
using steal_auto = steal_auto_impl<Stealer, Robbed>::type;
} // namespace meta

namespace meta {
template<
    template<class...> class Guild,
    template<auto...> class Stealer,
    class... UnsuspectingTargets
>
struct stealall_auto_impl {
    template<class Robbed>
    using stealer_closure = steal_auto<Stealer, Robbed>;

    using stealed_metalist = apply<stealer_closure, UnsuspectingTargets...>;

    using type = dress<Guild, stealed_metalist>;
};

template<
    template<class...> class Guild,
    template<auto...> class Stealer,
    class... UnsuspectingTargets
>
using stealall_auto = stealall_auto_impl<Guild, Stealer, UnsuspectingTargets...>::type;
} // namespace meta
#+end_src
#+depends:meta::stealall_auto :noweb meta::apply meta::dress


#+begin_src cpp :eval no-export :exports both :minipage :wrap "src default :minipage"
<<include(":noweb meta::stealall_auto print_type")>>

template<int X>
struct squared {
    static constexpr int result = X * X;
};

template<int X>
struct doubled {
    static constexpr int result = X * 2;
};

int main() {
    using double_steal = meta::stealall_auto<
        std::tuple, doubled,
        squared<4>, squared<8>, squared<15>,
        squared<16>, squared<23>, squared<42>
    >;
    print_type<double_steal>();
}
#+end_src

#+RESULTS:
#+begin_src default :minipage
std::tuple<doubled<4>, doubled<8>, doubled<15>, doubled<16>, doubled<23>, doubled<42> >
#+end_src


** Constexpr utilities

#+name: constexpr/abs
#+begin_src cpp :minipage
template<typename T>
constexpr T abs(T value) {
    return value >= 0 ? value: -value;
}
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb constexpr/abs print")>>

int main() {
    print{abs(-4)};
    print{abs(-8.1516)};
    print{abs(23.42)};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
4
8.1516
23.42
#+end_src


** Other utilities

*** Constructor side effect to lambda

Constructor side effect (cse) is the name of a trick consisting of using a type like a function.
This is what was used for the =print= function.
To be honest, I'm not sure if this trick is efficient.
Its usefulness with regards to the print function is to give a syntax to specify a custom separator and a custom end of line.

One problem with it is that it cannot be passed directly to a higher order function and is therefore not as versatile as a functor or a lambda.
=cse_lambda= bypasses this problem by converting a cse to a templated lambda.

#+name: cse_lambda
#+begin_src cpp :minipage
template<class ConstructorSideEffect>
auto cse_lambda() {
    return []<class... Args>(Args&&... args) {
        ConstructorSideEffect{std::forward<Args>(args)...};
    };
}
#+end_src
#+depends:cse_lambda :cpp utility

# ((
Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb cse_lambda print :cpp vector")>>

template<typename T, class Function>
void vector_apply(std::vector<T>& v, Function fun) {
    for(auto& el: v)
        fun(el);
}

int main() {
    std::vector<int> lost{4, 8, 15, 16, 23, 42};
    // vector_apply(lost, print);   // gcc error: missing template arguments before ‘)’ token
    // vector_apply(lost, print<>); // gcc error: expected primary-expression before ‘)’ token
    // vector_apply(lost, print()); // Not what is wanted, actually uses operator().
    vector_apply(lost, cse_lambda<print<>>());
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
4
8
15
16
23
42
#+end_src

=print<>= must be used because =print= is a templated type.


* Data structures

** Inventory

An inventory is a very simple data structure with only two main operations:
 1. =store= a value, returning a handle.
 2. =remove= stored values using their handle.

An inventory has the following constraints:
 1. Iteration on the elements is supported.
 2. Non hashable types (like =std::function=) are storable.
 3. Elements can be removed from anywhere without needing to reallocate the others.

This implementation is based on the doubly-linked lists from =std::list=.
Given the constraints, it's certainly possible to implement something much more efficient, but that will be an exercise for another day.

#+name: inventory
#+begin_src cpp :minipage
template<typename T>
class inventory {
  public:
    using warehouse = std::list<T>;
    using handle = warehouse::iterator;

    template<typename... Args>
    handle store(Args&&... args) {
        return storage_.emplace(storage_.end(), std::forward<Args>(args)...);
    }

    void remove(handle h) {storage_.erase(h);}
    std::size_t size() const {return storage_.size();}

    handle begin() const {return storage_.begin();}
    handle end() const {return storage_.end();}
    handle begin() {return storage_.begin();}
    handle end() {return storage_.end();}

  private:
    warehouse storage_;
};
#+end_src
#+depends:inventory :cpp list

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb inventory print :cpp functional")>>

void print_int(int x) {
    print{"print_int", x};
}

void print_inc_int(int x) {
    print{"print_inc_int", x + 1};
}

int main() {
    using fun = std::function<void(int)>;

    inventory<fun> funs;
    auto int_handle = funs.store(print_int);
    auto inc_int_handle = funs.store(print_inc_int);

    for(const auto f: funs)
        f(15);
    print{funs.size(), "functions stored.\n"};

    funs.remove(int_handle);
    for(const auto f: funs)
        f(22);
    print{funs.size(), "function stored."};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
print_int 15
print_inc_int 16
2 functions stored.

print_inc_int 23
1 function stored.
#+end_src


** Segmented storage

A =segstorage= is contiguous and can be manipulated as a container of segments of constant size rather than as a container of individual values.
It must therefore maintain an important invariant, the size of its underlying storage must always be a multiple of the size of its segments.

#+name: segstorage
#+begin_src cpp :minipage
template<class Storage, std::size_t SegmentSize>
struct segstorage {
    using value_type = Storage::value_type;
    static constexpr std::size_t segment_size = SegmentSize;
    using segment_type = std::span<value_type, segment_size>;
    Storage storage;

    std::size_t size() const;
    bool empty() const {return storage.empty();}

    <<segstorage/public>>
};
#+end_src
#+depends:segstorage :cpp span

*** Indexing

A =segstorage= can be indexed, with =std::span= being used to represent individual segments.

#+begin_src cpp :noweb-ref segstorage/qualified_generation
auto operator[](std::size_t index) Q__{
    return std::span<Q__value_type, SegmentSize>(
        storage.data() + SegmentSize * index,
        SegmentSize
    );
}
#+end_src

*** Iteration

The iterators have:
 - The bare minimum required to be usable in a range-based for loop (=++=, =*= and =!==).
 - Pointer addition (=+=).

#+begin_src cpp :noweb-ref segstorage/qualified_generation :minipage
struct Q_iterator {
    Q__value_type* ptr;
    Q_iterator& operator++() {
        ptr += SegmentSize;
        return *this;
    }

    auto operator*() const {
        return std::span<Q__value_type, SegmentSize>(ptr, SegmentSize);
    }

    bool operator!=(const Q_iterator& other) const {
        return other.ptr != ptr;
    }

    Q_iterator& operator+(std::size_t offset) {
        ptr += offset * SegmentSize;
        return *this;
    }
};
Q_iterator begin() Q__{return Q_iterator{storage.data()};}
Q_iterator end() Q__{return Q_iterator{storage.data() + storage.size()};}
#+end_src

*** Qualified code generation

The two previous sections used qualified syntax to make it possible to generate const and non const versions:
#+Call: gen-qualified(":name segstorage/qualified_generation :noweb_ref segstorage/public :pre :both :lvl ***") :results raw

#+RESULTS:

**** =segstorage/public= const

#+begin_src cpp :noweb-ref segstorage/public :minipage
auto operator[](std::size_t index) const {
    return std::span<const value_type, SegmentSize>(
        storage.data() + SegmentSize * index,
        SegmentSize
    );
}
struct const_iterator {
    const value_type* ptr;
    const_iterator& operator++() {
        ptr += SegmentSize;
        return *this;
    }

    auto operator*() const {
        return std::span<const value_type, SegmentSize>(ptr, SegmentSize);
    }

    bool operator!=(const const_iterator& other) const {
        return other.ptr != ptr;
    }

    const_iterator& operator+(std::size_t offset) {
        ptr += offset * SegmentSize;
        return *this;
    }
};
const_iterator begin() const {return const_iterator{storage.data()};}
const_iterator end() const {return const_iterator{storage.data() + storage.size()};}
#+end_src

**** =segstorage/public= non_const

#+begin_src cpp :noweb-ref segstorage/public :minipage
auto operator[](std::size_t index) {
    return std::span<value_type, SegmentSize>(
        storage.data() + SegmentSize * index,
        SegmentSize
    );
}
struct iterator {
    value_type* ptr;
    iterator& operator++() {
        ptr += SegmentSize;
        return *this;
    }

    auto operator*() const {
        return std::span<value_type, SegmentSize>(ptr, SegmentSize);
    }

    bool operator!=(const iterator& other) const {
        return other.ptr != ptr;
    }

    iterator& operator+(std::size_t offset) {
        ptr += offset * SegmentSize;
        return *this;
    }
};
iterator begin() {return iterator{storage.data()};}
iterator end() {return iterator{storage.data() + storage.size()};}
#+end_src

*** Ostream redirection


#+name: <<segstorage
#+begin_src cpp :minipage
template<class Storage, std::size_t SegmentSize>
std::ostream& operator<<(std::ostream& os, const segstorage<Storage, SegmentSize>& container) {
    return container_redirection::sequential(os, container);
}
#+end_src
#+depends:<<segstorage :noweb segstorage sequential_redirection <<span :cpp ostream

*** Segmented array

The invariant of a segmented array is verified by definition (=Size * SegmentSize=) and stays valid because its size is fixed.
#+name: segarray
#+begin_src cpp :minipage
template<class T, std::size_t Size, std::size_t SegmentSize>
struct segarray: segstorage<std::array<T, Size * SegmentSize>, SegmentSize> {
    constexpr std::size_t size() const {return Size;}
};
#+end_src
#+depends:segarray :noweb segstorage :cpp array
#+depends:<<segarray :noweb <<array <<segstorage

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb segarray out <<span print <<segarray")>>

int main() {
    segarray<int, 3, 2> lost{4, 8, 15, 16, 23, 42};
    print{"Size:         ", lost.size()};
    out("Iteration:    ");
    for(auto el: lost)
        out(" ", el);
    print{};
    print{"First element:", lost[0]};
    print{"All segments: ", lost};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Size:          3
Iteration:     [4, 8] [15, 16] [23, 42]
First element: [4, 8]
All segments:  [[4, 8], [15, 16], [23, 42]]
#+end_src

*** Segmented vector

The invariant of a segmented vector is maintained by:
 - The allocation of multiples of =SegmentSize= in =reserve=.
 - =push_back='s requirement that only allows it to accept =SegmentSize= arguments, translating into =SegmentSize= calls to the vector's own =push_back=.

It should be noted that nothing prevents the caller to call =push_back= or =reserve= manually on =storage=, since it is publicly accessible.
The invariant only holds when the storage is modified via =segvector='s methods.

#+name: segvector
#+begin_src cpp :minipage
template<class T, std::size_t SegmentSize>
struct segvector: public segstorage<std::vector<T>, SegmentSize> {
    std::size_t size() const {return this->storage.size() / SegmentSize;};
    std::size_t capacity() const {return this->storage.capacity() / SegmentSize;};

    void reserve(std::size_t new_cap) {
        this->storage.reserve(SegmentSize * new_cap);
    }

    void resize(std::size_t count, const T& value) {
        this->storage.resize(count * SegmentSize, value);
    }

    template<class... Args>
    requires(sizeof...(Args) == SegmentSize)
    void push_back(Args&&... args) {
        push_back_impl(std::forward<Args>(args)...);
    }

  private:
    template<class Arg, class... Args>
    void push_back_impl(Arg&& head, Args&&... tail) {
        this->storage.push_back(std::forward<Arg>(head));
        push_back_impl(std::forward<Args>(tail)...);
    }
    void push_back_impl(){}
};
#+end_src
#+depends:segvector :noweb segstorage :cpp vector
#+depends:<<segvector :noweb <<vector <<segstorage

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb segvector out <<span print <<segvector")>>

int main() {
    segvector<int, 2> lost;
    print{"Empty size:     ", lost.size()};
    out("Capacity:        ", lost.capacity(), " before, ");
    lost.reserve(3); print{lost.capacity(), "after"};
    lost.push_back(4, 8); print{"Adding [4, 8]:  ", lost.size(), lost};
    lost.push_back(15, 16); print{"Adding [15, 16]:", lost.size(), lost};
    lost.push_back(23, 42); print{"Adding [23, 42]:", lost.size(), lost};

    out("\nIteration:    ");
    for(auto el: lost)
        out(" ", el);
    print{};
    print{"First element:", lost[0]};
    print{"All segments: ", lost};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Empty size:      0
Capacity:        0 before, 3 after
Adding [4, 8]:   1 [[4, 8]]
Adding [15, 16]: 2 [[4, 8], [15, 16]]
Adding [23, 42]: 3 [[4, 8], [15, 16], [23, 42]]

Iteration:     [4, 8] [15, 16] [23, 42]
First element: [4, 8]
All segments:  [[4, 8], [15, 16], [23, 42]]
#+end_src

*** Segmented span

There is no way to ensure the validity of a =segspan= by construction, so a =valid= method is provided.

#+name: segspan
#+begin_src cpp :minipage
template<class T, std::size_t SegmentSize>
struct segspan: segstorage<std::span<T>, SegmentSize> {
    std::size_t size() const {return this->storage.size() / SegmentSize;}
    bool valid() const {return this->storage.size() % SegmentSize == 0;}
};
#+end_src
#+depends:segspan :noweb segstorage :cpp span
#+depends:<<segspan :noweb <<span <<segstorage

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb print <<vector segspan <<segspan :cpp vector")>>

int main() {
    std::vector lost{4, 8, 15, 16, 23, 42};
    print{lost};
    segspan<int, 2> seglost{lost};
    print{seglost};
    print{segspan<int, 3>{lost}};
    segspan<int, 4> segfault{lost};
    print{"seglost is", seglost.valid() ? "valid": "not valid"};
    print{"segfault is", segfault.valid() ? "valid": "not valid"};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
[4, 8, 15, 16, 23, 42]
[[4, 8], [15, 16], [23, 42]]
[[4, 8, 15], [16, 23, 42]]
seglost is valid
segfault is not valid
#+end_src


** Hash generation

Maps and sets are a pain to use when compared to other containers because of the need to define a hash function for everything outside the standard library.
This section implements utilities to quickly define hash functions.

*** Hash combinations

This was taken straight from https://stackoverflow.com/a/38140932, which was apparently inspired by Boost's own =hash_combine=.
I'm not sure of the usefulness of =inline= here.

#+name: hash_combine
#+begin_src cpp :noweb no
inline void hash_combine(std::size_t& seed) {}

template <typename T, typename... Rest>
inline void hash_combine(std::size_t& seed, const T& v, const Rest&... rest) {
    seed ^= std::hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);
    hash_combine(seed, rest...);
}
#+end_src
#+depends:hash_combine :cpp functional

*** Make hashable

This was also taken from https://stackoverflow.com/a/38140932.
#+name: MAKE_HASHABLE
#+begin_src cpp
#define MAKE_HASHABLE(type, ...) \
    namespace std {\
        template<> struct hash<type> {\
            std::size_t operator()(const type& t) const {\
                std::size_t ret = 0;\
                hash_combine(ret, __VA_ARGS__);\
                return ret;\
            }\
        };\
    }
#+end_src
#+depends:MAKE_HASHABLE :noweb hash_combine

The following =COMMA= trick will be necessary to use =MAKE_HASHABLE= on types with a comma, like =std::pair<int, int>=.
Without it the comma in =std::pair<int, int>= would be interpreted as the start of a new macro argument.
It comes from here https://stackoverflow.com/a/19841470.

#+name: COMMA
#+begin_src cpp
#define COMMA ,
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb MAKE_HASHABLE COMMA print <<pair :cpp utility map")>>

MAKE_HASHABLE(std::pair<int COMMA int>, t.first, t.second)

int main() {
    std::map<std::pair<int, int>, int> lost;
    lost[{4, 8}] = 15; lost[{16, 23}] = 42;
    for(auto& el: lost) {
        print{el.first, el.second};
    }
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
<4, 8> 15
<16, 23> 42
#+end_src

*** Standard library hashes

=MAKE_HASHABLE= is very useful but not suitable to write utilities in LitLib's style because it might result in multiple definitions of the same hash and therefore in compilation errors.
This section defines generic =hash= implementations for standard types that are suitable to use in LitLib code blocks.

#+name: hash/pair
#+begin_src cpp
namespace std {
template<typename First, typename Second>
struct hash<std::pair<First, Second>> {
    std::size_t operator()(const std::pair<First, Second>& p) const {
        std::size_t ret = 0;
        hash_combine(ret, p.first, p.second);
        return ret;
    }
};
}
#+end_src
#+depends:hash/pair :noweb hash_combine :cpp utility


** Coordinates

The coordinates presented here are more types that proper data structures.

*** 2d

#+name: xy_coords
#+begin_src cpp
template<typename T>
struct xy_coords {
    T x; T y;
    bool operator==(const xy_coords&) const=default;
};
#+end_src


* Functional programming

** Functional operators

This section defines binary operators that can be used to cobble functions together.
The idea (and the implementation of the first operator) was taken from http://cpptruths.blogspot.com/2016/12/folding-functions.html.

*** Composition

This can be used to feed the result of one function into the next.

#+name: compose
#+begin_src cpp :minipage
namespace compose {
template<class F, class G> auto operator |(F&& f, G&& g) {
    return [f, g](auto a) {return g(f(a));};
}
}
#+end_src

*** Sequence

Since this operator does not return anything, it is only useful for the side effects.

#+name: sequence
#+begin_src cpp :minipage
namespace sequence {
template<class F, class G> auto operator &(F&& f, G&& g) {
    return [f, g](auto a) {f(a); g(a);};
}
}
#+end_src

*** Usage

#+begin_src cpp :eval no-export :exports both :wrap "src default"
<<include(":noweb print print_size compose sequence")>>

int square(int x) {return x * x;}

struct plusx {
    int x;
    int operator()(int y) const {return x + y;}
};

void print_lost(const char* ignore) {
    print{4, 8, 15, 16, 23, 42};
}

struct print_chevron {
    void operator()(auto& el) const {
        print{el, " <"};
    }
};

int main() {
    using namespace compose;
    using namespace sequence;
    auto square_plus3 = square | [](int x) {return x + 2;} | plusx{1};
    auto piloch = [](const auto& el){print{el, "||"};} & print_lost & print_chevron{};

    print{"2 * 2 + 3 =", square_plus3(2)};
    piloch("sequence");
    print{};
    print_size(square_plus3);
    print_size(piloch);
}
#+end_src


#+RESULTS:
#+begin_src default
2 * 2 + 3 = 7
sequence ||
4 8 15 16 23 42
sequence  <

compose::operator|<compose::operator|<int (&)(int), main()::<lambda(int)> >(int (&)(int), main()::<lambda(int)>&&)::<lambda(auto:11)>, plusx>(compose::operator|<int (&)(int), main()::<lambda(int)> >(int (&)(int), main()::<lambda(int)>&&)::<lambda(auto:11)>&&, plusx&&)::<lambda(auto:11)> -> 24 bytes (192 bits)
sequence::operator&<sequence::operator&<main()::<lambda(const auto:14&)>, void (&)(const char*)>(main()::<lambda(const auto:14&)>&&, void (&)(const char*))::<lambda(auto:12)>, print_chevron>(sequence::operator&<main()::<lambda(const auto:14&)>, void (&)(const char*)>(main()::<lambda(const auto:14&)>&&, void (&)(const char*))::<lambda(auto:12)>&&, print_chevron&&)::<lambda(auto:12)> -> 24 bytes (192 bits)
#+end_src


** Pure functions
*** Nothing

This lambda does nothing, no matter what you give it. It's my favourite.
#+name: nothing
#+begin_src cpp
auto nothing = []<class... T>(const T&...) {};
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb print nothing")>>

int main() {
    print{"Nothing to see."};
    nothing(4, 8, 15, 16, 23, 42);
    nothing();
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Nothing to see.
#+end_src

In all seriousness, this is very useful when an interface expects a callback but no side effect is needed.

*** Identity

#+name: identity
#+begin_src cpp
struct identity {
    template<class T> T& operator()(T& arg) const {return arg;}
    template<class T> const T& operator()(const T& arg) const {return arg;}
};
#+end_src


* Various utilities

This section is dedicated to utilities without overarching themes.

** Math
*** Sum of a container

I didn't like the idea of using =std::accumulate= with a begin iterator, a end iterator and a mandatory neutral element, so I made the =sum= template for a more Python-like experience.

I also didn't like the fact that using =std::accumulate= specifically for this it adds a dependency.
Limiting dependencies is crucial to LitLib's developpement style since everything needs to be recompiled everytime.

#+name: sum
#+begin_src cpp :minipage
template<class Container>
typename Container::value_type sum(const Container& source, typename Container::value_type neutral=0) {
    for(const auto& el: source)
        neutral += el;
    return neutral;
}
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb sum print :cpp vector array span")>>

int main() {
    std::vector<int> lost_v{4, 8, 15, 16, 23, 42};
    std::array<int, 6> lost_a{4, 8, 15, 16, 23, 42};
    std::span<int> lost_s(lost_v);
    print{"Sum of lost numbers with a std::vector:", sum(lost_v)};
    print{"Same thing with a std::array:", sum(lost_a)};
    print{"Same thing with a std::span:", sum(lost_s)};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Sum of lost numbers with a std::vector: 108
Same thing with a std::array: 108
Same thing with a std::span: 108
#+end_src
\\

This template does not work directly with C arrays but wrapping them in =std::span= makes it work:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb sum print :cpp span")>>
int main() {
    float lost[]{4, 8, 15, 16, 23, 42};
    print{"Sum of lost numbers with a C array, via std::span:", sum(std::span(lost))};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Sum of lost numbers with a C array, via std::span: 108
#+end_src

*** Minmax

#+name: min
#+begin_src cpp
template<class T>
const T& min(const T& left, const T& right) {
    return left < right ? left: right;
}
#+end_src

#+name: max
#+begin_src cpp
template<class T>
const T& max(const T& left, const T& right) {
    return left > right ? left: right;
}
#+end_src

*** Midpoint computation

This implementation is compatible with containers defining a =value_type=.
It's up to the caller to ensure that the containers have the correct length.

#+name: fill_midpoint
#+begin_src cpp
template<class Midpoint, class Left, class Right>
requires std::same_as<typename Midpoint::value_type, typename Left::value_type>
      && std::same_as<typename Midpoint::value_type, typename Right::value_type>
Midpoint& fill_midpoint(Midpoint& midpoint, const Left& left, const Right& right) {
    auto leftit = left.cbegin(); auto rightit = right.cbegin();
    for(
        auto midit = midpoint.begin();
        midit != midpoint.end();
        ++midit, ++leftit, ++rightit
    )
        *midit = (*leftit + *rightit) / 2;
    return midpoint;
}
#+end_src
#+depends:fill_midpoint :cpp concepts

A specialisation for =std::span= is handy because passing by reference does not work well with spans.
#+name: fill_midpoint/span
#+begin_src cpp
template<class T, std::size_t Extent>
std::span<T, Extent> fill_midpoint(
    std::span<T, Extent> midpoint, std::span<T, Extent> left, std::span<T, Extent> right
) {
    auto leftit = left.begin(); auto rightit = right.begin();
    for(
        auto midit = midpoint.begin();
        midit != midpoint.end();
        ++midit, ++leftit, ++rightit
    )
        *midit = (*leftit + *rightit) / 2;
    return midpoint;
}
#+end_src
#+depends:fill_midpoint/span :cpp span

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb print fill_midpoint <<vector :cpp vector")>>

int main() {
    std::vector<float> green{ 0,  1,  0};
    std::vector<float>  blue{ 0,  0,  1};
    std::vector<float>  teal{-1, -1, -1};
    print{"The midpoint of", green, "and", blue, "is", fill_midpoint(teal, green, blue)};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
The midpoint of [0, 1, 0] and [0, 0, 1] is [0, 0.5, 0.5]
#+end_src


** Conversions
*** To span

This section defines a =to_span= function that can convert a contiguous container to a span.
Most of the implementation logic is hidden in its own namespace:
#+begin_src cpp :noweb-ref to_span :minipage
namespace to_span_details {
template<
    class Container,
    std::size_t Extent,
    std::size_t Offset = 0
> struct impl {
    using value_type = typename Container::value_type;
    static auto convert(Container& container) {
        return std::span<value_type, Extent>(
            container.data() + Offset,
            Extent - Offset
        );
    }

    static auto convert(const Container& container) {
        return std::span<const value_type, Extent>(
            container.data() + Offset,
            Extent - Offset
        );
    }
};

<<to_span_details>>
} // namespace to_span_impl
#+end_src
#+depends:to_span :cpp span

Dynamic extents must use the =size= method to take into account the actual size of the container:
#+begin_src cpp :noweb-ref to_span_details :minipage
template<
    class Container,
    std::size_t Offset
> struct impl<Container, std::dynamic_extent, Offset> {
    static auto convert(Container& container) {
        return std::span<typename Container::value_type, std::dynamic_extent>(
            container.data() + Offset,
            container.size() - Offset
        );
    }

    static auto convert(const Container& container) {
        return std::span<const typename Container::value_type, std::dynamic_extent>(
            container.data() + Offset,
            container.size() - Offset
        );
    }
};
#+end_src

The actual =to_span= function:
#+begin_src cpp :noweb-ref to_span :minipage
template<
    std::size_t Extent = std::dynamic_extent,
    std::size_t Offset = 0,
    class Container
> auto to_span(Container& container) {
    return to_span_details::impl<Container, Extent, Offset>::convert(container);
}

template<
    std::size_t Extent = std::dynamic_extent,
    std::size_t Offset = 0,
    class Container
> auto to_span(const Container& container) {
    return to_span_details::impl<Container, Extent, Offset>::convert(container);
}
#+end_src

=to_span_offset= inverts the =Offset= and =Extent= template arguments.
This is mostly useful to use an offset on a span with a dynamic extent.
For example, =to_span<std::dynamic_extent, 6>(data)= can be expressed as =to_span_offset<6>(data)=.

#+name: to_span_offset
#+begin_src cpp :minipage
template<
    std::size_t Offset = 0,
    std::size_t Extent = std::dynamic_extent,
    class Container
> auto to_span_offset(Container& container) {
    return to_span<Extent, Offset, Container>(container);
}

template<
    std::size_t Offset = 0,
    std::size_t Extent = std::dynamic_extent,
    class Container
> auto to_span_offset(const Container& container) {
    return to_span<Extent, Offset, Container>(container);
}
#+end_src
#+depends:to_span_offset :noweb to_span

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb print to_span to_span_offset <<span :cpp vector array")>>

int main() {
    const std::vector lost{4, 8, 15, 16, 23, 42};
    print{to_span<4>(lost)};
    print{to_span_offset<4>(lost)};

    std::array other{6, 108};
    auto other_span = to_span(other);
    std::swap(other_span[0], other_span[1]);
    print{other_span};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
[4, 8, 15, 16]
[23, 42]
[108, 6]
#+end_src

*** Between scales of numbers

=scale_converter= can convert linearly between two scales of a given type.
The type used for the conversion can be specified via the =ConvType= template parameter.

#+name: scale_converter
#+begin_src cpp
template<class From, class To, class ConvType=float>
struct scale_converter {
    template<class T>
    struct extremum {
        T low;
        T high;
    };
    extremum<From> from;
    extremum<To> to;
    ConvType proportion;

    scale_converter(extremum<From> from_, extremum<To> to_):
        from(from_), to(to_), proportion(
            static_cast<ConvType>(to.high - to.low) /
            static_cast<ConvType>(from.high - from.low)
        )
    {}

    To convert(From value) {
        return static_cast<To>(static_cast<ConvType>(value - from.low) * proportion) + to.low;
    }

    To convert_bounded(From value) {
        if(value <= from.low)
            return to.low;
        if(value >= from.high)
            return to.high;
        return convert(value);
    }
};
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb out scale_converter")>>

int main() {
    scale_converter<float, int> percent_to_lost({0.f, 100.f}, {4, 42});
    scale_converter<int, float> lost_to_percent({4, 42}, {0.f, 100.f});
    for(float i: {-50, 0, 10, 20, 25, 50, 74, 75, 76, 100, 12000}) {
        int conversion = percent_to_lost.convert(i);
        out(i, "% -> ", conversion, " lost -> ", lost_to_percent.convert(conversion), "%\n");
    }
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
-50% -> -15 lost -> -50%
0% -> 4 lost -> 0%
10% -> 7 lost -> 7.89474%
20% -> 11 lost -> 18.4211%
25% -> 13 lost -> 23.6842%
50% -> 23 lost -> 50%
74% -> 32 lost -> 73.6842%
75% -> 32 lost -> 73.6842%
76% -> 32 lost -> 73.6842%
100% -> 42 lost -> 100%
12000% -> 4564 lost -> 12000%
#+end_src


** Finaliser

=finaliser= is a class that can be returned from a function and trigger a side effect when the object is destroyed, thus tying the action to the scope of the =finaliser=.
It is an alternative version of the unimplemented =anchor= class discussed in a later section.
#+name: finaliser
#+begin_src cpp
template<typename Callable, typename State=int>
class finaliser {
  public:
    finaliser(Callable side_effect):
        side_effect_(std::move(side_effect))
    {}

    finaliser(State initial_state, Callable side_effect):
        side_effect_(std::move(side_effect)),
        state_(std::move(initial_state))
    {}

    ~finaliser() {
        side_effect_(state_);
    }

    finaliser(const finaliser&)=delete;
    finaliser& operator=(const finaliser&)=delete;
    finaliser(finaliser&&)=delete;
    finaliser& operator=(finaliser&&)=delete;
    finaliser()=delete;

  protected:
    Callable side_effect_;
    State state_;
};
#+end_src

Some notes on this implementation:
 - A state is baked in to allow some customisation of the side effect's behaviour by extending =finaliser=.
 - I'm constructing with =std::move= because I assume that it doesn't hurt in the cases where it's useless (with =int= in particular) and that it can be useful should someone need to store a huge state in here.
 - Every special member function under the sun is deleted because, by default, a given side effect should only be called once.

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb finaliser print <<vector :cpp vector")>>

[[nodiscard("Will cleanup immediately.")]]
auto cleanup_later(std::vector<int>& numbers) {
    return finaliser([&](int){
        print{"Will clean", numbers};
        numbers.clear();
        print{"Die alone", numbers};
    });
}

int main() {
    print{"Live together."};
    std::vector<int> a_scenario_with_loose_ends{4, 8, 15, 16, 23};
    auto finale = cleanup_later(a_scenario_with_loose_ends);
    print{"Adding 42."};
    a_scenario_with_loose_ends.push_back(42);
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Live together.
Adding 42.
Will clean [4, 8, 15, 16, 23, 42]
Die alone []
#+end_src

Note that when the return value is ignored, the side effect is enacted immediately, resulting in the following output:
#+begin_src text :minipage
Live together.
Will clean [4, 8, 15, 16, 23]
Die alone []
Adding 42.
#+end_src

This can be problematic but I have no solution, only the slight mitigation of using the =nodiscard= attribute to generate a compiler warning should a return value be ignored.

For an example using the internal state, see =subscription= in the next section.


** Subscription

A =subscription= object is an extension of =finaliser= providing a method to =cancel= itself.
The side effect is notified of this state change.
Cancelling the subscription also changes the internal state to =already_cancelled=, to allow the side effect to make the difference between the destruction of an active subscription and that of an already cancelled subscription.

As should be expected, a subscription can only be cancelled once, additional cancelling will not trigger the side effect again.

#+name: subscription
#+begin_src cpp :minipage
enum class subscription_state {active, cancel, already_cancelled};

template<typename Callable>
struct subscription: public finaliser<Callable, subscription_state> {
    using state = subscription_state;
    subscription(Callable side_effect):
        finaliser<Callable, subscription_state>(state::active, std::move(side_effect))
    {}

    void cancel() {
        if(this->state_ == state::active) {
            this->side_effect_(state::cancel);
            this->state_ = state::already_cancelled;
        }
    }
};
#+end_src
#+depends:subscription :noweb finaliser

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb subscription print")>>

auto verbose_subscription() {
    return subscription([](auto state){
        using s = subscription_state;
        if(state == s::active)
            print{"active"};
        else if(state == s::cancel)
            print{"cancel"};
        else if(state == s::already_cancelled)
            print{"already cancelled"};
    });
}

int main() {
    auto will_not_cancel = verbose_subscription();
    auto will_cancel = verbose_subscription();
    will_cancel.cancel();
    will_cancel.cancel();
    print{"End of scope."};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
cancel
End of scope.
already cancelled
active
#+end_src

As desired, the second cancellation does nothing.


** Observable

An observable corresponds to the observer pattern but implemented from the point of view of the observed object.
The idea is that =observable= holds a value of type =Observed=, whose evolution can be tracked from the outside by registering a consumer of =Observed= with the method =observe=.

The implementation is splitted across the next subsections and here is its outline:
#+name: observable
#+begin_src cpp :minipage
template<typename Observed>
class observable {
  public:
    using observer_storage = std::function<void(const Observed&)>;
    <<observable/public>>

  private:
    Observed observed_;
    inventory<observer_storage> observers_;
    <<observable/private>>
};
#+end_src
#+depends:observable :noweb subscription inventory :cpp functional

*** Observation

An observer's lifetime is handled via a =subscription=.
Note that there is no handling of the case where the =observable= is destroyed before its =observer=.
Doing this would probably crash the program right now.

#+begin_src cpp :noweb-ref observable/public :minipage
template<typename Observer>
[[nodiscard("An ignored observer subscription will be destroyed before anything can be observed.")]]
auto observe(Observer&& observer) {
    using s = subscription_state;
    auto handle = observers_.store(std::forward<Observer>(observer));
    return subscription([this, handle](s state){
        if(state == s::active || state == s::cancel)
            observers_.remove(handle);
    });
}
#+end_src

=notify= can be used internally to call all the registered observers with the current observed value.
#+begin_src cpp :noweb-ref observable/private :minipage
void notify() {
    for(auto observer: observers_)
        observer(observed_);
}
#+end_src

*** Lifecycle

The assignment operator is where all the magic occurs since it allows the stored value to be updated as if it was of type =Observed= and then notifies the observers.
Thus for example, an =obvervable<int>= can be updated as if it was actually =int= and trigger a notification to all observers.

#+begin_src cpp :noweb-ref observable/public :minipage
template<typename T>
observable& operator=(T&& new_value) {
    observed_ = std::forward<T>(new_value);
    notify();
    return *this;
}
#+end_src

The =Observed= constructor is the only one defined because there is no obvious semantic for moving around an =observable=.
Therefore constructing the =observable= and updating its =Observed= value is the only valid semantic for now.

#+begin_src cpp :noweb-ref observable/public :minipage
observable(Observed&& initial):
    observed_(std::forward<Observed>(initial))
{}

observable(const observable&)=delete;
observable& operator=(const observable&)=delete;
observable(observable&&)=delete;
observable& operator=(observable&&)=delete;
observable()=delete;
#+end_src

*** Access

Members of =Observed= can still be accessed via the =->= operator:
#+begin_src cpp :noweb-ref observable/public :minipage
const Observed* operator->() const {
    return &observed_;
}
#+end_src

*** Usage

#+begin_src cpp :eval no-export :exports both
<<include(":noweb observable print print_size <<vector :cpp vector")>>

void prefix_print(int x) {
    print{x, "<-"};
}

void postfix_print(int x) {
    print{"->", x};
}

void infix_print(int x) {
    print{{.sep=""}}("|", x, "|");
}

struct pair {
    int first;
    int second;
};

int main() {
    std::vector<int> lost = {4, 8, 15, 16, 23, 42};
    observable<int> number(0);

    // An easy mistake to make.
    number.observe(prefix_print);
    auto postfix_sub = number.observe(postfix_print);
    auto infix_sub = number.observe(infix_print);

    print{"||| Printing frenzy |||"};
    for(auto el: lost)
        number = el;

    print{"\n||| Types information |||"};
    print_size<decltype(infix_sub)>();
    print_size<decltype(number)>();
    print_size<decltype(number)::observer_storage>();

    print{"\n||| Access |||"};
    observable<pair> last({23, 42});
    print{last->first, last->second};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
||| Printing frenzy |||
-> 4
|4|
-> 8
|8|
-> 15
|15|
-> 16
|16|
-> 23
|23|
-> 42
|42|

||| Types information |||
subscription<observable<Observed>::observe<void (&)(int)>::<lambda(s)> > -> 24 bytes (192 bits)
observable<int> -> 32 bytes (256 bits)
std::function<void(const int&)> -> 32 bytes (256 bits)

||| Access |||
23 42
#+end_src

The biggest problem of =observable= is the fact that the caller can easily forget to store the subscription.
A feature similar to =[[nodiscard]]= but that simply refuses to compile would be great to fix this.
Alternatively, a scoped object could be passed to observe alongside the observer.
This might actually be more convenient at the call site.


** Linear interpolation

This utility can be used to interpolate values linearly between several data points.
It was conceived with color gradient creation via a =segstorage= in mind, but it might eventually prove useful for other things.

#+name: linear_interpolation
#+begin_src cpp :minipage
template<typename SegmentedStorage>
struct linear_interpolation {
    using value_type = SegmentedStorage::value_type;
    static constexpr std::size_t segment_size = SegmentedStorage::segment_size;
    using data_point = SegmentedStorage::segment_type;

    SegmentedStorage storage;

    <<linear_interpolation/public>>
};
#+end_src
#+depends:linear_interpolation :noweb min :cpp span cmath

*** Fill with interpolation

The =fill= function expects a =progress= parameter between 0 and 1, representing the point from which the value should be interpolated.
#+begin_src cpp :noweb-ref linear_interpolation/public :minipage
void fill(data_point destination, float progress) const {
    auto intervals = storage.size() - 1;
    float remainder = progress * intervals;

    std::size_t left = min<std::size_t>(std::floor(remainder), intervals);
    std::size_t right = left + 1;
    if(right >= storage.size())
        right = 0;
    remainder -= left;

    for(std::size_t i = 0; i < segment_size; ++i) {
        destination[i] = storage[left][i] * (1 - remainder) + storage[right][i] * remainder;
    }
}
#+end_src

This overload represents =progress= as a number of steps:
#+begin_src cpp :noweb-ref linear_interpolation/public :minipage
void fill(data_point destination, std::size_t current, std::size_t steps) const {
    fill(destination, static_cast<float>(current) / static_cast<float>(steps - 1));
}
#+end_src

=fill_all= can fill a whole container of segments with interpolated values:
#+begin_src cpp :noweb-ref linear_interpolation/public :minipage
template<typename OtherStorage>
void fill_all(OtherStorage& destination) const {
    for(std::size_t i = 0; i < destination.size(); ++i) {
        fill(destination[i], i, destination.size());
    }
}
#+end_src

*** Color alias

It is a bit simplistic to assume a float representation but this will be enough for an OpenGL usage.

#+name: rgb_interpolation
#+begin_src cpp :minipage
template<template<typename, std::size_t, std::size_t> class Support, std::size_t Size>
using rgb_interpolation = linear_interpolation<Support<float, Size, 3>>;
#+end_src
#+depends:rgb_interpolation :noweb linear_interpolation

*** Usage

#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb rgb_interpolation segarray print <<span <<array")>>

int main() {
    print{"Red to green to blue:"};
    rgb_interpolation<segarray, 3> rgb_gradient{
        1, 0, 0, // r
        0, 1, 0, // g
        0, 0, 1  // b
    };
    segarray<float, 9, 3> rgb_dest;
    rgb_gradient.fill_all(rgb_dest);
    for(const auto& color: rgb_dest)
        print{color};

    print{"\nRed:"};
    rgb_interpolation<segarray, 1> r_nongradient{1, 0, 0};
    segarray<float, 4, 3> r_dest;
    r_nongradient.fill_all(r_dest);
    for(const auto& color: r_dest)
        print{color};

    print{"\nPointer arithmetic:"};
    auto ptr = rgb_dest.begin();
    print{"rbg first:", *ptr, "==", rgb_dest[0]};
    ptr = ptr + 4;
    print{"rgb fifth:", *ptr, "==", rgb_dest[4]};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
Red to green to blue:
[1, 0, 0]
[0.75, 0.25, 0]
[0.5, 0.5, 0]
[0.25, 0.75, 0]
[0, 1, 0]
[0, 0.75, 0.25]
[0, 0.5, 0.5]
[0, 0.25, 0.75]
[0, 0, 1]

Red:
[1, 0, 0]
[1, 0, 0]
[1, 0, 0]
[1, 0, 0]

Pointer arithmetic:
rbg first: [1, 0, 0] == [1, 0, 0]
rgb fifth: [0, 1, 0] == [0, 1, 0]
#+end_src


** Scaled interpolation

Where =linear_interpolation= gave the same importance to all the data points, with =scaled_interpolation= it is possible to, in a way, give more importance to some data points by putting more distance between its neighbours.

#+name: scaled_interpolation
#+begin_src cpp
namespace scaled_interpolation_details {
template<typename ScalarT, typename DataT, std::size_t SegmentSize, typename InterpT=float>
class scaled_interpolation {
  public:
    using data_point = std::span<DataT, SegmentSize>;
    using scalar_type = ScalarT;
    struct step {
        ScalarT scalar;
        std::array<DataT, SegmentSize> data;
    };

    std::vector<step> storage;

    void fill(data_point destination, ScalarT scalar) const {
        auto right = find_right(scalar);
        if(right == 0)
            fill_without_interpolation(destination, 0);
        else if(right >= storage.size())
            fill_without_interpolation(destination, storage.size() - 1);

        else {
            auto left = right - 1;
            InterpT proportion = static_cast<InterpT>(scalar - storage[left].scalar) /
                                 static_cast<InterpT>(storage[right].scalar - storage[left].scalar);
            for(std::size_t i = 0; i < SegmentSize; ++i)
                destination[i] = storage[left].data[i] * (1 - proportion)
                               + storage[right].data[i] * proportion;
        }
    }

    ScalarT min() const {return storage.front().scalar;}
    ScalarT max() const {return storage.back().scalar;}

  private:
    void fill_without_interpolation(data_point destination, std::size_t index) const {
        for(std::size_t i = 0; i < SegmentSize; ++i)
            destination[i] = storage[index].data[i];
    }

    std::size_t find_right(ScalarT scalar) const {
        std::size_t result = 0;
        for(; result < storage.size(); ++result)
            if(storage[result].scalar > scalar)
                break;
        return result;
    }
};

}
using scaled_interpolation_details::scaled_interpolation;
#+end_src
#+depends:scaled_interpolation :cpp array vector span

#+name: rgb_scaled_interpolation
#+begin_src cpp
template<typename ScalarT, typename InterpT=float>
using rgb_scaled_interpolation = scaled_interpolation<ScalarT, float, 3, InterpT>;
#+end_src
#+depends:rgb_scaled_interpolation :noweb scaled_interpolation

Usage:
#+begin_src cpp :eval no-export :exports both
<<include(":noweb print <<array rgb_scaled_interpolation :cpp array")>>

int main() {
    rgb_scaled_interpolation<int> rgb_skewed_gradient{{
        {0,  {1, 0, 0}},
        {3,  {0, 1, 0}},
        {10, {0, 0, 1}}
    }};
    std::array<float, 3> color_buffer;
    for(int i = -1; i <= 12; ++i) {
        rgb_skewed_gradient.fill(color_buffer, i);
        print{i, color_buffer};
    }
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
-1 [1, 0, 0]
0 [1, 0, 0]
1 [0.666667, 0.333333, 0]
2 [0.333333, 0.666667, 0]
3 [0, 1, 0]
4 [0, 0.857143, 0.142857]
5 [0, 0.714286, 0.285714]
6 [0, 0.571429, 0.428571]
7 [0, 0.428571, 0.571429]
8 [0, 0.285714, 0.714286]
9 [0, 0.142857, 0.857143]
10 [0, 0, 1]
11 [0, 0, 1]
12 [0, 0, 1]
#+end_src

The following can transform the scale of a =scaled_interpolation= based on new min and max values:
#+name: transform_scaled_interpolation
#+begin_src cpp
template<class ScaleType>
ScaleType& transform_scaled_interpolation(
    ScaleType& scale,
    typename ScaleType::scalar_type min,
    typename ScaleType::scalar_type max
) {
    scale_converter<typename ScaleType::scalar_type, typename ScaleType::scalar_type> conv(
        {scale.min(), scale.max()}, {min, max}
    );
    for(auto& step: scale.storage)
        step.scalar = conv.convert(step.scalar);
    return scale;
}
#+end_src
#+depends:transform_scaled_interpolation :noweb scale_converter


* Cool tricks (don't try this at home)

This section is dedicated to weird C++ voltige.
It might be dangerous, useless or plain stupid but it is (subjectively) always interesting and can raise new way to abuse the language.

** Mandatory keyword arguments

Designated initialisers in C++20 enable a syntax reminiscent to Python keyword arguments, although more verbose and limited.
A problem is that there is, to my knowledge, no built-in way to specify that a keyword argument is mandatory.

Let's use the example of the following =user= class:
#+name: example-mandatory-user
#+begin_src cpp :minipage
class user {
  public:
    struct keyword_arguments {
        std::string group = "others";
        std::string name;
        unsigned long id;
    };
    user(keyword_arguments&& kwargs):
        group_(std::move(kwargs.group)),
        name_(std::move(kwargs.name)),
        id_(kwargs.id)
    {
        print{"group:", group_};
        print{"name:", name_};
        print{"id:", id_};
    }

  private:
    std::string group_, name_;
    unsigned long id_;
};
#+end_src
#+depends:example-mandatory-user :noweb print :cpp string

In the following executable, since nothing has been defined for =name= and =id=, the default value for =string= and =unsigned int= are used instead.
This code is perfectly valid, it compiles and executes without problem.
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb example-mandatory-user")>>

int main() {
    user richard({});
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
group: others
name: 
id: 0
#+end_src

To force an error when =name= and =id= are not defined, the =mandatory= template can be used.
#+name: mandatory
#+begin_src cpp :minipage
template<typename T>
class mandatory {
  public:
    template<typename... Args>
    mandatory(Args&&... args): value_(std::forward<Args>(args)...)
    {}
    mandatory()=delete;

    const T& operator*() const {return value_;}
    T& operator*() {return value_;}

  private:
    T value_;
};
#+end_src

Some remarks about =mandatory=:
 - The trick is that since the default constructor is deleted, fields wrapped in =mandatory= cannot be silently given a default value.
 - The variadic-template-forwarding constructor gives some flexibility to the way arguments can be assigned.
   In particular without it =std::string= assignments like ={.name = "ricardo"}= fail silently because, I assume, C++ then considers =.name= to be a =char *=.
 - The =*= operator must be used to extract the value since I did not managed to make a working =T= conversion operator.
   I assume move operations performed on the references returned by this operator will work as expected but I'm way out of my knowledge zone.
\\

Beyond declaring =name= and =id= as mandatory fields, this is not fully transparent as some adaptation to the =user= class is required, in the form of putting an asterisk in front of the mandatory arguments when they are used:
#+name: example-mandatory-user-fixed
#+begin_src cpp :minipage
class user {
  public:
    struct keyword_arguments {
        std::string group = "others";
        mandatory<std::string> name;
        mandatory<unsigned long> id;
    };
    user(keyword_arguments&& kwargs):
        group_(std::move(kwargs.group)),
        name_(std::move(*kwargs.name)),
        id_(*kwargs.id)
    {
        print{"group:", group_};
        print{"name:", name_};
        print{"id:", id_};
    }

  private:
    std::string group_, name_;
    unsigned long id_;
};
#+end_src
#+depends:example-mandatory-user-fixed :noweb mandatory print :cpp string

Now the following code does not compile:
#+begin_src cpp :eval never :minipage
<<include(":noweb example-mandatory-user-fixed")>>

int main() {
    user richard({});
}
#+end_src

I am instead greeted by the following error messages:
#+begin_src default :minipage
/tmp/babel-QfQ93l/C-src-wPBlHJ.cpp: In function ‘int main()’:
/tmp/babel-QfQ93l/C-src-wPBlHJ.cpp:104:20: error: use of deleted function ‘mandatory<T>::mandatory() [with T = std::__cxx11::basic_string<char>]’
  104 |     user richard({});
      |                    ^
/tmp/babel-QfQ93l/C-src-wPBlHJ.cpp:16:5: note: declared here
   16 |     mandatory()=delete;
      |     ^~~~~~~~~
/tmp/babel-QfQ93l/C-src-wPBlHJ.cpp:104:20: error: use of deleted function ‘mandatory<T>::mandatory() [with T = long unsigned int]’
  104 |     user richard({});
      |                    ^
/tmp/babel-QfQ93l/C-src-wPBlHJ.cpp:16:5: note: declared here
   16 |     mandatory()=delete;
      |     ^~~~~~~~~
#+end_src
Which are surprisingly appropriate, I am pleasantly surprised.

If only one mandatory argument is supplied, a compilation error is also triggered for the missing field.
On the other hand, the following code works as expected:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb example-mandatory-user-fixed")>>

int main() {
    user richard({.name = "ricardo", .id = 4815162342});
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
group: others
name: ricardo
id: 4815162342
#+end_src


** Anchor (fun with(out) RVO)

The initial goal of the =anchor= is to have a function returning an =anchor= object that will perform an action on destruction but that action depends on whether the object was ignored.
Metaphorically, the function is a boat throwing an anchor that is either lost (the return value is ignored) or touches the seafloor (the return value is assigned).
But really the anchor terminology was chosen because it's about anchoring something in another scope.

The paragraph above talked about an initial goal because I didn't manage to make it work.
To be precise, I didn't manage to know whether the =anchor= was ignored or not.
Therefore =anchor= is not implemented but it is still explored in the rest of this section.

*** Bypassing RVO

A problem with =anchor= is that in order to known whether it has been assigned, it must rely on side effect enacted by copy constructors.
A naive implementation will not work because return value optimisation (RVO) will bypass the copy operation.
Thus a mechanism must be put in place to bypass RVO itself.

From what I understand, C++ compilers are not authorised to optimise away named volatile objects (in other words to perform NRVO on them).
I hope that's true, it at least seems to be what is meant by the following passage from [[https://en.cppreference.com/w/cpp/language/copy_elision#Non-mandatory_elision_of_copy.2Fmove_.28since_C.2B.2B11.29_operations][cppreference.com]][fn::Consulted on 2021-08-08.], about when compilers are *permitted* to perform copy elision:
#+begin_quote
In a return statement, when the operand is the name of a non-volatile object with automatic storage duration, which isn't a function parameter or a catch clause parameter, and which is of the same class type (ignoring cv-qualification) as the function return type. This variant of copy elision is known as NRVO, "named return value optimization".
#+end_quote
What's important here is that this passage states that a non-volatile named object can be elided, which to me implies that volatile named objects just cannot be elided in a return statement.

*** Remove volatile qualifier

To implement =anchor=, a way to remove a volatile qualifier will be needed because nothing works otherwise.
Forcibly ignoring a qualifier is a bit brutal but I have no problem with the idea here since =volatile= is only used to bypass RVO.
It turns out that const casts also removes volatile qualifiers:
#+name: unvolatile
#+begin_src cpp :minipage
template<typename T>
constexpr T& unvolatile(volatile T& arg) {
    return *const_cast<T*>(&arg);
}
#+end_src

Usage:
#+begin_src cpp :eval no-export :exports both :minipage
<<include(":noweb unvolatile print :cpp string")>>
int main() {
    std::string lo("4 8 15");
    volatile std::string st("16 23 42");
    print{lo, unvolatile(st)};
}
#+end_src

#+RESULTS:
#+begin_src text :minipage
4 8 15 16 23 42
#+end_src

Note that without =unvolatile=, the previous code block fails with the following error:
#+begin_src default
error: no matching function for call to ‘std::__cxx11::basic_string<char>::basic_string(volatile string&)’
#+end_src

*** Observing RVO

This section will show how RVO can be bypassed with =volatile= but also why trying to check if a return value was ignored cannot be done this way.
To fulfill this, the =talkative= struct updates its state everytime a relevant event occurs and also prints said event.

#+name: talkative-example
#+begin_src cpp
struct talkative {
    talkative(const std::string& initial_state):
        state(initial_state)
    {}

    talkative(const talkative& other):
        state(other.state)
    {process("copy_c");}

    talkative(volatile talkative&& other):
        state(std::move(unvolatile(other.state)))
    {
        process("volatile-move_c");
        unvolatile(other.state) = "Stolen volatile!";
    }

    talkative(talkative&& other):
        state(std::move(other.state))
    {
        process("move_c");
        unvolatile(other.state) = "Stolen!";
    }

    ~talkative() {
        print{"destroying:", state};
        // Just for sanity's sake.
        state += ", destroyed";
    }

    talkative& operator=(const talkative&)=delete;
    talkative& operator=(talkative&&)=delete;
    talkative()=delete;

    std::string state;
    void process(std::string const& event) {
        print{event};
        state += ", " + event;
    }
};
#+end_src
#+depends:talkative-example :noweb print unvolatile :cpp string

=talkative= is used below to generate a trace explaining what happens.
#+begin_src cpp :eval no-export :wrap "src text"
<<include(":noweb talkative-example print type_str :cpp string")>>

int n = 1;
void title(std::string const& name) {
    print{std::string("\n") + std::to_string(n) + ".", "|||", name, "|||"};
    ++n;
}

talkative return_plain(std::string const& initial) {
    title(initial);
    talkative result(initial);
    return result;
}

talkative return_move(std::string const& initial) {
    title(initial);
    talkative result(initial);
    return std::move(result);
}

talkative return_volatile(std::string const& initial) {
    title(initial);
    volatile talkative result(initial);
    return result;
}

int main() {
    auto result_plain = return_plain("Plain captured");
    auto result_move = return_move("Move captured");
    auto result_volatile = return_volatile("Volatile captured");

    return_plain("Plain ignored");
    return_move("Move ignored");
    return_volatile("Volatile ignored");

    title("Types");
    print{"Type of result_plain:", type_str<decltype(result_plain)>()};
    print{"Type of result_move:", type_str<decltype(result_move)>()};
    print{"Type of result_volatile:", type_str<decltype(result_volatile)>()};
    volatile talkative explicitely_volatile("ignoreme");
    print{"Type of explicitely_volatile:", type_str<decltype(explicitely_volatile)>()};

    title("End of scope");
}
#+end_src

#+RESULTS:
#+begin_src text

1. ||| Plain captured |||

2. ||| Move captured |||
move_c
destroying: Stolen!

3. ||| Volatile captured |||
volatile-move_c
destroying: Stolen volatile!

4. ||| Plain ignored |||
destroying: Plain ignored

5. ||| Move ignored |||
move_c
destroying: Stolen!
destroying: Move ignored, move_c

6. ||| Volatile ignored |||
volatile-move_c
destroying: Stolen volatile!
destroying: Volatile ignored, volatile-move_c

7. ||| Types |||
Type of result_plain: talkative
Type of result_move: talkative
Type of result_volatile: talkative
Type of explicitely_volatile: volatile talkative

8. ||| End of scope |||
destroying: ignoreme
destroying: Volatile captured, volatile-move_c
destroying: Move captured, move_c
destroying: Plain captured
#+end_src

To summarise the output above:
 1. Nothing happens, =result_plain= is constructed in place because of RVO.
 2. The result is moved into =result_move= via the move constructor and the original is destroyed.
 3. The result is moved into =result_volatile= via the volatile move constructor and the original is destroyed.
 4. The plain result is destroyed.
 5. The result is moved into a temporary and both are destroyed.
 6. The result is moved into a temporary and both are destroyed.
 7. All captured results are plain =talkative=.
 8. The destructors are called at the end of scope.

This is not what I hoped because there is no way to know whether the variable was ignored.
What I hoped was that returning a named volatile would not construct a plain object, unless the return was assigned to something.

Some lessons learned:
 - RVO can indeed be bypassed by returning a named volatile.
 - It can apparently be bypassed in a similar way with =std::move= but with a compiler warning telling you not to do that.
